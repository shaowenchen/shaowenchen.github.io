<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>CI on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/ci/</link><description>Recent content in CI on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Fri, 17 Jan 2025 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/ci/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用 Nerdctl 构建多架构镜像</title><link>https://www.chenshaowen.com/blog/use-nerdctl-to-build-multi-architecture-images.html</link><pubDate>Fri, 17 Jan 2025 00:00:00 +0000</pubDate><atom:modified>Fri, 17 Jan 2025 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/use-nerdctl-to-build-multi-architecture-images.html</guid><description>1. Nerdctl 安装 安装 Opscli 1 curl -sfL https://raw.githubusercontent.com/shaowenchen/ops/main/getcli.sh |VERSION=latest sh - 安装 Nerdctl 1 opscli task -f install-nerdctl --arch amd64 2. BuildKit 下载 Buildkit 1 wget https://github.com/moby/buildkit/releases/download/v0.19.0-rc2/buildkit-v0.19.0-rc2.linux-amd64.tar.gz 安装 Buildkit 1 2 tar xvf buildkit-*.tar.gz mv bin/* /usr/local/bin/ 配置 Buildkitd 1 mkdir -p /etc/buildkit /data/buildkit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cat &amp;gt; /etc/buildkit/buildkitd.toml &amp;lt;&amp;lt;EOF debug = true root = &amp;#34;/data/buildkit&amp;#34; [worker.oci] enabled = false [worker.containerd] address = &amp;#34;/run/containerd/containerd.sock&amp;#34; enabled = true platforms = [ &amp;#34;linux/amd64&amp;#34;, &amp;#34;linux/arm64&amp;#34; ] namespace = &amp;#34;buildkit&amp;#34; gc = true gckeepstorage = 9000 cniPoolSize = 16 EOF 生成 Systemd Unit 文件 1 2 3 4 5 6 7 8</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>多架构</category><category>镜像</category><category>CI</category><category>Nerdctl</category></item><item><title>优化 Tekton 执行克隆任务慢问题，节省约 30 秒</title><link>https://www.chenshaowen.com/blog/optimizing-the-slow-of-tekton-clone-task.html</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><atom:modified>Thu, 16 Feb 2023 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/optimizing-the-slow-of-tekton-clone-task.html</guid><description>1. 现象 - Tekton 克隆代码任务慢 在执行克隆任务时，Tekton 很费时间，多仓库下一般都需要 2 分 30 秒左右。如下图: 仅克隆的流水线就需要执行 2 分钟 16 秒，而克隆脚本实际上仅执行 1-3 秒。其中大部分时间花在了哪里？能不能减少？这是本篇主要想讨论的问题。 2. 分析克</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Tekton</category><category>Kubernetes</category><category>CI</category><category>CICD</category><category>DevOps</category></item><item><title>分阶段构建如何缓存第三方依赖</title><link>https://www.chenshaowen.com/blog/how-to-cache-third-party-package-whilie-building-in-stage.html</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><atom:modified>Tue, 22 Feb 2022 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-cache-third-party-package-whilie-building-in-stage.html</guid><description>非分阶段构建场景下，使用容器进行构建时，我们可以将容器中的缓存目录挂载到构建主机上，执行构建任务；然后将产物拷贝到运行镜像，制作应用镜像。但是在分阶段构建时，构建镜像和运行镜像在同一个 Dockerfile 中，这给优化第三方依赖的缓存带来了难度。 1. 创建一个 Vue 实</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>CICD</category><category>CI</category><category>DevOps</category><category>缓存</category><category>优化</category></item><item><title>如何接入远程 macOS 物理机进行 Jenkins 流水线构建</title><link>https://www.chenshaowen.com/blog/how-to-run-the-pipeline-on-remote-osx.html</link><pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate><atom:modified>Sun, 22 Nov 2020 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-run-the-pipeline-on-remote-osx.html</guid><description>本文同样适用于接入 ARM、MIPS 架构，FreeBSD、Windows 系统的物理机，如果 Jenkins 能连上构建机，可以跳过 Frp 部分。 1. 遇到的问题 在以 Kubernetes 为基础设施的场景下，Jenkins 构建流水线时，将为每一条流水线单独创建一个 Pod 用于构建。Pod 中的容器</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Jenkins</category><category>macOS</category><category>CICD</category><category>CI</category><category>DevOps</category></item><item><title>如何在 Docker 中使用 Docker</title><link>https://www.chenshaowen.com/blog/how-to-use-docker-in-docker.html</link><pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate><atom:modified>Sat, 21 Nov 2020 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-docker-in-docker.html</guid><description>1. 典型适用场景 在 CI 中，通常会有一个 CI Engine 负责解析流程，控制整个构建过程，而将真正的构建交给 Agent 去完成。例如，Jenkins 、GitLab 均是如此。 如下图, 连接 CI Engine 的 Agent, 种类很多。这是为了满足不同项目对构建环境的要求。 同时 Agent 是动态的，构建时才需要，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>Kubernetes</category><category>Containers</category><category>CI</category></item><item><title>如何利用 CDN 进一步的前后端分离 - CI 脚本</title><link>https://www.chenshaowen.com/blog/ci-script-of-how-to-use-cdn-to-separate-frontend-and-backend-more.html</link><pubDate>Sat, 15 Sep 2018 00:00:00 +0000</pubDate><atom:modified>Sat, 15 Sep 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/ci-script-of-how-to-use-cdn-to-separate-frontend-and-backend-more.html</guid><description>在团队中，开发流程相关的调整一定要相应的自动化工具配合。如果没有足够低的使用成本，这种调整将会是无意义的，因为根本就不会有人去使用。上一篇，我们提到 如何利用 CDN 进一步的前后端分离 , 这一篇主要讲，如何将这个流程结合到 CI 中。后端的配置，之前的 博客</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>CI</category><category>优化</category><category>部署</category><category>PaaS</category><category>脚本</category><category>DevOps</category></item><item><title>如何利用 CDN 进一步的前后端分离</title><link>https://www.chenshaowen.com/blog/how-to-use-cdn-to-separate-frontend-and-backend-more.html</link><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><atom:modified>Thu, 13 Sep 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-cdn-to-separate-frontend-and-backend-more.html</guid><description>最近在优化一下项目，梳理整个链路之后，开始逐步优化，发现了很多可以改进的点。下面是对开发模式、部署方式的一些思考，希望对你有所启发。 1. 开发背景 1.1 部署方式 如上图，简单描述一下应用的架构。 采用的是经典三层架构，接入层，逻辑层，存储层。其中，接入</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>CI</category><category>优化</category><category>部署</category><category>PaaS</category></item><item><title>常用的一些 CI 脚本</title><link>https://www.chenshaowen.com/blog/some-common-scripts-in-ci.html</link><pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 17 Jul 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/some-common-scripts-in-ci.html</guid><description>由于负责小组的 CI 公共事项，经常需要配置 CI 流程，或者帮助其他人解决一些问题，整理了一下常用的 CI 脚本，以方便查阅。 1. .gitlab-ci.yml 结构 下面是， GitLab CI 的配置文件结构。 .gitlab-ci.yml 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 一些前置脚本，完成激活环境等操作 before_script: - source /data/runner/node/bin/activate - which node &amp;amp;&amp;amp; node --version - which npm</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>GitLab</category><category>CI</category><category>DevOps</category><category>持续集成</category></item><item><title>GitLab CI 配置 Runner</title><link>https://www.chenshaowen.com/blog/gitlab-ci-configuring-runner.html</link><pubDate>Tue, 08 May 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 08 May 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/gitlab-ci-configuring-runner.html</guid><description>1. 下载并配置 Runner 1.1 下载 Runner GitLab-CI 的 Runner 是一个 Go 写的程序包，可以去官网下载到本地。 1 2 yum install -y wget wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 增加执行权限 1 chmod +x /usr/local/bin/gitlab-runner 1.2 新增 runner 用户 运行 Runner 时，以 runner:runner 账户运行。 1 2 groupadd -g 1234 runner useradd runner -u 1234 -g 1234 1.3 修改 pip 源 1 2 3 4 cat /etc/pip.conf [global] index-url= http://pypi.doubanio.com/simple/ trusted-host = pypi.doubanio.com 1.4 创建工作目录 1 mkdir -p /data/gitlab-data 2 注册 Runner 在项目</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>GitLab</category><category>CI</category><category>DevOps</category></item><item><title>基于 Git 的前后端开发工作流</title><link>https://www.chenshaowen.com/blog/based-on-git-development-workflow-of-front-and-back.html</link><pubDate>Sat, 31 Mar 2018 00:00:00 +0000</pubDate><atom:modified>Sat, 31 Mar 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/based-on-git-development-workflow-of-front-and-back.html</guid><description>最近参与了一个多人协作开发的项目，在开发过程中遇到不少问题。例如，前端提交冲掉后端代码、代码冲突无法解决直接返工、A 提交 B 分支、直接提交 Master 分支等。本文是记录，也是思考如何更高质量地管理项目、进行多人合作项目的开发。 1. 版本管理的需求 1.1 版本标记</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>效率</category><category>合作</category><category>CI</category><category>DevOps</category></item></channel></rss>