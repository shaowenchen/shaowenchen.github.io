<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Celery on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/celery/</link><description>Recent content in Celery on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Wed, 24 Oct 2018 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/celery/atom.xml" rel="self" type="application/rss+xml"/><item><title>Celery 处理大文件失败问题排查与解决</title><link>https://www.chenshaowen.com/blog/solving-the-problem-of-celery-processe-large-file-failure.html</link><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><atom:modified>Wed, 24 Oct 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/solving-the-problem-of-celery-processe-large-file-failure.html</guid><description>1. 一个小需求 经常遇到一些小的需求，但是实现起来并不简单。这里就有一个文件上传的简单需求，分为下面几个步骤： 用户在页面上传一个大文件 大文件会被暂存在内网的 Ceph 后台任务，将 Ceph 中的大文件，下载到 Docker 内 后台任务，将 Docker 中的大文件，上传到外网的 COS 后台使用的</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Celery</category><category>故障</category><category>排查</category><category>大文件</category><category>问题</category></item><item><title>RabbitMQ 消息队列</title><link>https://www.chenshaowen.com/blog/message-queue-about-rabbitmq.html</link><pubDate>Sat, 23 Dec 2017 20:51:22 +0000</pubDate><atom:modified>Sat, 23 Dec 2017 20:51:22 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/message-queue-about-rabbitmq.html</guid><description>1. 消息队列的适用场景 1.1 异步处理 应用场景：用户注册后，需要发注册邮件和注册短信。同步的处理方法，系统的性能（并发量，吞吐量，响应时间）会有瓶颈。 1.2 应用解耦 应用场景：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>RabbitMQ</category><category>中间件</category><category>Celery</category><category>消息</category><category>队列</category></item><item><title>Django 中 Celery 的应用</title><link>https://www.chenshaowen.com/blog/using-celery-in-django.html</link><pubDate>Tue, 25 Oct 2016 07:57:59 +0000</pubDate><atom:modified>Tue, 25 Oct 2016 07:57:59 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-celery-in-django.html</guid><description>场景一:公司准备给全部员工推送一个邮件公告。采用封装的邮件库API，使用一次循环遍历全部员工推送邮件，会使主程序卡在循环处无法响应，这是我们不愿意看到的，我们希望点击执行之后，可以正常其他操作。场景二，量化程序的本地回测数据库每天都要更新。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Celery</category><category>Django</category><category>博文</category></item></channel></rss>