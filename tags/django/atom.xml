<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Django on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/django/</link><description>Recent content in Django on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Mon, 03 Jun 2019 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/django/atom.xml" rel="self" type="application/rss+xml"/><item><title>django-xss-cleaner</title><link>https://www.chenshaowen.com/blog/django-xss-cleaner.html</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><atom:modified>Mon, 03 Jun 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-xss-cleaner.html</guid><description>django-xss-cleaner 是一个基于 bleach 的 Django XSSFilter 工具包，实现了对 GET 和 POST 请求参数的 XSS 白名单过滤功能。包中内置了部分白名单 HTML 标签、属性设置，同时也支持自定义扩展。项目地址，https://github.com/shaowenchen/django-xss-cleaner 1.</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>XSS</category><category>Django</category><category>安全</category></item><item><title>Django 性能之数据库查询优化</title><link>https://www.chenshaowen.com/blog/database-query-optimization-of-django-performance.html</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><atom:modified>Wed, 20 Mar 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/database-query-optimization-of-django-performance.html</guid><description>本文主要提供了 Django 字段、查询方面的优化建议，同时还介绍了一个 Django-silk 性能分析工具。希望对你开发高性能的 Django 工程有所帮助。 1. DBA 的建议 1.1 表字段设计 避免出现 null 值，null 值难以查询优化且占用额外的索引空间 尽量使用 INT 而非 BIGINT，尽可能准确描述字段 使用枚</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据库</category><category>优化</category><category>性能</category><category>Django</category></item><item><title>Django 性能之分库分表</title><link>https://www.chenshaowen.com/blog/sub-db-and-table-of-django-performance.html</link><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><atom:modified>Tue, 19 Mar 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/sub-db-and-table-of-django-performance.html</guid><description>1. 碰到的问题 前端请求量大，并发高，访问速度慢，瓶颈主要表现在： 单表大 单库大 网络 IO 慢 磁盘 IO 慢 网络、磁盘 IO 优化，主要依靠硬件升级。理论上，数据库对单库、单表的大小没有限制，但是过大的单库、单表会导致更多的请求落到单机上，给 IO 造成压力。 理想情况是</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据库</category><category>Sharding</category><category>性能</category><category>分库</category><category>分表</category></item><item><title>开发 Tips（7）</title><link>https://www.chenshaowen.com/blog/developing-tips-7.html</link><pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate><atom:modified>Sun, 24 Feb 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/developing-tips-7.html</guid><description>主要记录最近遇到的一些开发问题，解决方法。 1. Python2 和 Python3 中的异常处理 Python2，Python3 都支持的两种方式： 带参数 1 2 except （ExceptionType） as Argument: # 访问 Argument 不带参数 1 except ExceptionType： 仅 Python2 支持的方式： 1 2 except ExceptionType, Argument: # 访问 Argument 2.</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Tips</category><category>Python</category><category>Django</category></item><item><title>如何使用 Jenkins、Docker、GitLab 搭建 Django 自动化部署流程</title><link>https://www.chenshaowen.com/blog/how-to-use-jenkins-docker-gitlab-to-build-django-automated-deployment-process.html</link><pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Sun, 25 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-jenkins-docker-gitlab-to-build-django-automated-deployment-process.html</guid><description>大公司的程序员，容易产生的错觉之一就是，误将平台能力当作自己的能力。在大团队，我们不应仅关注自己的一亩三分地，更需要了解平台的各个环节。一方面，有助于更好地利用平台相关特性，另一方面，也为了自我技术更好地成长。本文，介绍了如何使用 Jekin</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>GitLab</category><category>Jenkins</category><category>Docker</category><category>DevOps</category></item><item><title>restframework 中 Serializer 和 ViewSet 的 API</title><link>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</link><pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 20 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</guid><description>1. Serializer 1.1 数据校验 在反序列化数据时，需要对数据的合法性进行校验。这时，可以调用 is_valid() 进行验证，如果发生验证错误，可以在 .errors 属性获取错误提示信息。例如： 1 2 3 4 serializer.is_valid() # False serializer.errors # {&amp;#39;created&amp;#39;: [u&amp;#39;This field is required.&amp;#39;]} .is_valid() 方法带有一个可选的 raise_exception 标志，如果存在验证错误，将抛出 serializers.ValidationError 异常。 1 serializer.is_valid(raise_exception=True) 除了使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>接口</category></item><item><title>restframework 中的 Viewset 和 Serializer</title><link>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</link><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Sun, 18 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</guid><description>1. Django 中的 View Class 首先回忆一下，Django 对请求的处理逻辑。收到一次请求之后，Django 会生成一个 WSGIHandler 类型的 handler，由 handler 控制整个处理流程。 那么，请求的 URL 与 View 是如何关联的呢？ Django 首先根据 ROOT_URLCONF 的配置加载 URLconf，按顺序逐个匹配 URLconf 的 URLp</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>框架</category><category>接口</category></item><item><title>Django 全栈优化指南</title><link>https://www.chenshaowen.com/blog/django-full-stack-optimization-guide.html</link><pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Thu, 15 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-full-stack-optimization-guide.html</guid><description>由于数据量剧增，系统响应很慢。对应用系统进行了一系列的优化工作，系统响应时间得到了数量级级别的优化效果。总体看，在压缩文件、加快网络访问方面的优化，对前端性能有显著提升效果。在存储过程、缓存、逻辑代码方面的优化，对后端性能提升有显著效果。本</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>优化</category><category>前端</category><category>后端</category><category>指南</category></item><item><title>开发 Tips（4）</title><link>https://www.chenshaowen.com/blog/developing-tips-4.html</link><pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Sun, 11 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/developing-tips-4.html</guid><description>主要记录最近遇到的一些开发问题，解决方法。 1. WhiteNoise 转发静态文件 Django 内置的静态文件服务器效率很低，而 WhiteNoise 是一个不错的替代品。具有如下特点： 通常用于 PaaS 服务 支持 wsgi 应用程序，针对 Django 进行了特殊适配 配合 CDN 使用，更佳 在 Gunicorn 配合下，使用 sendfile 系统调用，处理效率非常高 相比</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Tips</category><category>文件</category><category>Django</category><category>CentOS</category><category>Docker</category></item><item><title>如何使用 Django Signal 解耦模块</title><link>https://www.chenshaowen.com/blog/how-to-use-django-signal-decoupling-module.html</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><atom:modified>Fri, 12 Oct 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-django-signal-decoupling-module.html</guid><description>最近，我负责开发一个重后端的应用。这个应用数据流向复杂，处理逻辑冗余堆积。项目技术栈选择的是 Django + Vuejs。前端使用 Webpack 打包，模块化管理，主要是展示数据。后端涉及的模块多，处理规则多，数据表多，每次涉及之前功能修改时，都消耗大量时间 review 代码。这</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>设计</category><category>解耦</category><category>Demo</category></item><item><title>如何在 Django 中任意安全获取 request</title><link>https://www.chenshaowen.com/blog/how-to-secure-get-request-in-django.html</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 26 Jun 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-secure-get-request-in-django.html</guid><description>在 Django 中，request 包含了一次请求的全部信息。后端处理逻辑经常需要用到 request 中的信息。比如， DRF 框架中想要随时能够获取到 request，或者将一些参数全局传递。Django 第三方 App 中有一些工具可以满足要求，但它们并不是安全可靠的。意思是，如果 Django</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category></item><item><title>如何在 Django 中保证并发的数据一致性</title><link>https://www.chenshaowen.com/blog/how-to-ensure-concurrence-of-data-in-django.html</link><pubDate>Mon, 25 Jun 2018 12:00:00 +0000</pubDate><atom:modified>Mon, 25 Jun 2018 12:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-ensure-concurrence-of-data-in-django.html</guid><description>前面一部分主要讲乐观锁和悲观锁。锁从数据库层面，保证了并发时的数据一致性。了解锁，有助于对并发解决方案的理解。后面一部分主要讲的是 Django 中，并发场景下，保证数据一致性的解决办法。 1. 关于锁 1.1 乐观锁 乐观锁的出发点是，同一条数据很少会因为并发修改而产</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>并发</category></item><item><title>Django 中使用 utf8mb4 支持 emoji 表情</title><link>https://www.chenshaowen.com/blog/using-utf8mb4-in-django-to-support-emoji-expression.html</link><pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate><atom:modified>Mon, 25 Jun 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-utf8mb4-in-django-to-support-emoji-expression.html</guid><description>1. 什么是 utf8 理论上，utf8 使用 1-6 个字符， 实际上，最新的 utf8 规范只使用一到四个字节，最大能编码21位，正好能够表示所有的 17个 Unicode 平面。 2. 什么是 utf8mb4 utf8mb4 是 utf8 的超集，理论上原来使用 utf8，然后将字符集修改为 utf8mb4，也不会对已有的utf8 编码读</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>字符集</category><category>编码</category><category>表情包</category></item><item><title>Django 开发中常用命令</title><link>https://www.chenshaowen.com/blog/common-commands-in-django-development.html</link><pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate><atom:modified>Thu, 22 Mar 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/common-commands-in-django-development.html</guid><description>创建 Django 工程 1 django-admin startproject your_project_name 创建应用 1 2 3 django-admin.py startapp your_app_name # 或者 python manage.py startapp your_app_name python manage.py 和 django-admin 的功能基本一样。不同的是 python manage.py 还设置了 DJANGO_SETTINGS_MODULE 环境变量、将项目的路径加入了 sys.path 中。建议除了创建项目使用 django-admin，其他情况使用 python manage.py。 初始化数据 1 python manage.py migrate 创建缓存表</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>Django</category><category>命令</category></item><item><title>Django Model 与 E-R 图</title><link>https://www.chenshaowen.com/blog/django-model-and-er-diagram.html</link><pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate><atom:modified>Fri, 02 Mar 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-model-and-er-diagram.html</guid><description>在需求逐步确认的过程中，系统的 DB 模型也逐步确认。有时使用，MySQL Workbench 这类工具绘制 E-R 图，然后生成 MySQL 数据库表，这时就需要反向生成 Django Models；有时直接写 Django Models ，但是又需要查看 E-R 图。本文主要解决上面两个需求，实现 Django Models 与 E-R 图之间的转换。 1. 生成 model 的</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据库</category><category>设计</category><category>Model</category></item><item><title>Django 开发规范(一)</title><link>https://www.chenshaowen.com/blog/development-specification-1-of-django.html</link><pubDate>Sat, 27 Jan 2018 00:00:00 +0000</pubDate><atom:modified>Sat, 27 Jan 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/development-specification-1-of-django.html</guid><description>本文主要约定在 Django 开发过程中，需要注意的一些事项。统一的编码风格，良好的设计理念，有利于项目的开发和维护，值得开发人员不断地研究和探讨。 1. 编码声明 在 Python 解释器执行代码时，需要告诉解释器代码的编码方式。Python 代码实际上是文本数据，如果代码的</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Python</category><category>规范</category><category>研发</category></item><item><title>Python 中的进程、线程、协程</title><link>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</link><pubDate>Sat, 06 Jan 2018 11:22:55 +0000</pubDate><atom:modified>Sat, 06 Jan 2018 11:22:55 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</guid><description>1. 进程 进程是正在运行的程序实例，是内核分配资源的最基本的单元。进程拥有自己独立的堆和栈，独立的地址空间，资源句柄。进程由 OS 调度，调度开销较大，在并发的切换过程效率较低。 Python 提供了一个跨平台的多进程模块 multiprocessing，模块中使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>并发</category></item><item><title>无状态服务</title><link>https://www.chenshaowen.com/blog/stateless-service.html</link><pubDate>Wed, 03 Jan 2018 17:22:45 +0000</pubDate><atom:modified>Wed, 03 Jan 2018 17:22:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/stateless-service.html</guid><description>1.问题描述 背景：一个 Django 开发的 SaaS 应用，对外提供文档服务功能。其中，搜索功能通过 Django Haystack 实现。 问题：搜索功能有时可用，有时不可用。多次测试，发现可用和不可用会交替出现，出现概率各占约 50%。 补充一下搜索功能实现的细节： Django Haystack 在提供搜索功能之前，需要</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>服务</category><category>PaaS</category><category>SaaS</category></item><item><title>API 接口规范</title><link>https://www.chenshaowen.com/blog/api-interface-specification.html</link><pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate><atom:modified>Fri, 01 Dec 2017 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-interface-specification.html</guid><description>在 Web 应用开发的过程中，后端开发人员需要频繁的交付 API 接口，前端开发人员需要频繁的调用 API 接口。为了降低沟通成本、预防可能的安全风险，遵循约定优于配置的原则，有必要规范 API 的接口规范。Restful API 是以资源为核心的 API 设计思路，所有的操作都是针对特</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>研发</category><category>规范</category></item><item><title>错误码设计以及 Django 的异常统一处理</title><link>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</link><pubDate>Mon, 30 Oct 2017 21:50:33 +0000</pubDate><atom:modified>Mon, 30 Oct 2017 21:50:33 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</guid><description>笔者目前使用 Django 从事 SaaS 开发，同时开发和维护多个 SaaS 应用。在很多 SaaS 应用中都约定了错误码，有的用于处理登录态，有的用于标记业务逻辑状态。对于这种项目共性很强的特征，花时间学习和研究是非常有必要的。本篇主要讨论了错误码的用途、如何设计错误码、使用 Django 中</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>错误码</category><category>中间件</category></item><item><title>怎样打包一个 Python 包，并上传到 PyPi</title><link>https://www.chenshaowen.com/blog/how-to-pack-a-python-package-and-upload-it-to-pypi.html</link><pubDate>Fri, 06 Oct 2017 20:50:41 +0000</pubDate><atom:modified>Fri, 06 Oct 2017 20:50:41 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-pack-a-python-package-and-upload-it-to-pypi.html</guid><description>最近笔者在思考，怎样提高开发效率。从网络爬虫到数据处理，然后到人工智能。Python 的强大之处在于：拥有一大批开箱即用的工具包，不必重复造轮子，极大地提高了开发的效率。那么为何不将项目中的功能模块化，打包成可复用的 Python 包呢？本文主要讲的是怎样</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>Django</category><category>部署</category></item><item><title>Django 调试工具 django-debug-toolbar</title><link>https://www.chenshaowen.com/blog/django-debug-toolbar.html</link><pubDate>Fri, 06 Oct 2017 10:45:58 +0000</pubDate><atom:modified>Fri, 06 Oct 2017 10:45:58 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-debug-toolbar.html</guid><description>1. 关于 Django 的性能 Django 是一个 Python 写的 Web 应用框架。使用 Django ，可以非常简单、高效地开发复杂的数据驱动的网站。同时，Django 非常注重组件的重用性、可插拔、敏捷开发、DRY（Don&amp;rsquo;t Repeat Yourself）。从一定程度上讲，Django 是一个很</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>工具</category><category>测试</category><category>性能</category><category>调试</category></item><item><title>Django 中对静态文件版本的控制</title><link>https://www.chenshaowen.com/blog/control-of-static-file-version-in-django.html</link><pubDate>Fri, 06 Oct 2017 09:58:43 +0000</pubDate><atom:modified>Fri, 06 Oct 2017 09:58:43 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/control-of-static-file-version-in-django.html</guid><description>为了快速地响应用户的需求、满足运营活动的需要，互联网产品通常有着非常高的发布频率。采用敏捷开发的方式，缩短了交付的周期，加快了产品的迭代，也给项目的文件管理带来了挑战。前端工程直接面向用户，首当其冲，最值得重视。频繁更新的图片、样式、交互，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>前端</category><category>JavaScript</category><category>文件</category><category>研发</category><category>版本</category></item><item><title>Django 静态文件处理</title><link>https://www.chenshaowen.com/blog/django-static-file-processing.html</link><pubDate>Thu, 05 Oct 2017 15:42:27 +0000</pubDate><atom:modified>Thu, 05 Oct 2017 15:42:27 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-static-file-processing.html</guid><description>1. Django 静态文件分类 Django 静态文件分为两类：static 和 media。 static： 是页面引用的 JS、CSS、Image 等文件 media：是用户上传的文件 2. 生产环境配置 生产环境，通常配置 Nginx 转发静态文件请求，而 Django 处理动态请求。 nginx 配置 1 2 3 4 5 6 7 location /media</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>前端</category><category>文件</category><category>Python</category></item><item><title>Django 大文件传输</title><link>https://www.chenshaowen.com/blog/django-big-file-transfer.html</link><pubDate>Tue, 26 Sep 2017 18:28:56 +0000</pubDate><atom:modified>Tue, 26 Sep 2017 18:28:56 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-big-file-transfer.html</guid><description>1. 直接返回文件 如果静态文件在工程根目录的 media/test.zip，需要先将文件读入内存，再进行传输。代码如下： settings.py 配置 1 2 PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__)) MEDIA_ROOT = os.path.join(PROJECT_ROOT, &amp;#39;media/&amp;#39;) yourapp/views.py 1 2 3 4 5 6 7 8 9 10 11 12 from django.conf import settings from django.http import HttpResponse from django.core.files.storage import FileSystemStorage def download_file_direct_from_file(request): file_system = FileSystemStorage(settings.MEDIA_ROOT) file_name = &amp;#39;test.zip&amp;#39; with file_system.open(file_name) as f: response = HttpResponse(f) response[&amp;#39;Content-Type&amp;#39;] = &amp;#39;application/%s&amp;#39; % file_name.split(&amp;#39;.&amp;#39;)[-1] response[&amp;#39;Content-Disposition&amp;#39;] = &amp;#39;attachment; filename=&amp;#34;%s&amp;#34;&amp;#39;% file_name return</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>Django</category><category>大文件</category><category>网络</category><category>Demo</category></item><item><title>Vagrant 搭建 Django 开发环境</title><link>https://www.chenshaowen.com/blog/build-django-development-environment-using-vagrant.html</link><pubDate>Mon, 25 Sep 2017 21:56:05 +0000</pubDate><atom:modified>Mon, 25 Sep 2017 21:56:05 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/build-django-development-environment-using-vagrant.html</guid><description>Docker 解决了同一机器上的环境隔离问题，提高了运维部署的效率。 Vagrant 给开发提供一个统一的开发、测试、接近于完全隔离的环境。本文，主要讨论如何使用 Vagrant 搭建 Django 开发环境。版本：VirtualBox 5.0，Vagrant 1.8。 1. 基本概念 1.1 Vagrant Vagrant 是一个用来构建虚</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Vagrant</category><category>工具</category><category>开发</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (6) uWSGI、Django</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-6.html</link><pubDate>Sun, 24 Sep 2017 18:03:22 +0000</pubDate><atom:modified>Sun, 24 Sep 2017 18:03:22 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-6.html</guid><description>1. 目录结构 django-devops-uwsgi 目录是打包 uWSGI 和 Django 的镜像编译文件。在镜像中安装 uWSGI、pip、virtualenv等必要的程序包。 在使用镜像创建容器时，执行 start.sh 脚本， 创建 Python 虚拟运行环境，从 Django 的 requirements.txt 安装依赖包，最后启动 uWSGI 监听端口，等待请求。 django-devops-compose/www/app 目录，用于放置 Django 的代码</description><dc:creator>微信公众号</dc:creator><category>Docker</category><category>Django</category><category>服务</category><category>工具</category><category>博文</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (5) Nginx</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-5.html</link><pubDate>Sun, 24 Sep 2017 14:34:35 +0000</pubDate><atom:modified>Sun, 24 Sep 2017 14:34:35 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-5.html</guid><description>1. 目录结构 1 2 3 4 5 6 7 8 9 10 11 12 ├── django-devops-nginx │ ├── Dockerfile │ └── nginx.repo ├── django-devops-compose │ ├── docker-compose.yml │ ├── www │ ├── conf │ │ ├── nginx.conf │ ├── log │ │ ├── nginx │ │ │ ├── access.log │ │ │ ├── error.log 每个服务的镜像 Dockerfile，单独放在一个文件夹。django-devo</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>服务</category><category>工具</category><category>Django</category><category>Nginx</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (4) 项目组织</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-4.html</link><pubDate>Sun, 24 Sep 2017 13:32:40 +0000</pubDate><atom:modified>Sun, 24 Sep 2017 13:32:40 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-4.html</guid><description>1. 部署架构 浏览器访问一个页面的程序处理流程： (1)，浏览器向 Nginx 发起一个请求，如果匹配到 Nginx 的静态 URL，比如 /static 目录下的 js、css、404.html 等文件，那么 Nginx 直接返回文件。其他请求 URL，通过 uwsgi_pass 配置转给 uWSGI 处理。 (2)，uWSGI 解析请求头</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>服务</category><category>工具</category><category>Django</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (3) Docker Compose</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-3.html</link><pubDate>Sat, 23 Sep 2017 19:56:03 +0000</pubDate><atom:modified>Sat, 23 Sep 2017 19:56:03 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-3.html</guid><description>1. 基本概念 Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具。使用 Docker Compose，可以在一个文件中定义一个多容器应用，然后使用一条命令来启动你的应用，完成一切准备工作。 Docker Compose 定位是 &amp;lsquo;defining and running complex applications with Docker&amp;rsquo;，前身是 Fig，兼容 Fig 的模板文件</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>服务</category><category>工具</category><category>Django</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (2) Dockerfile</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-2.html</link><pubDate>Fri, 22 Sep 2017 19:52:27 +0000</pubDate><atom:modified>Fri, 22 Sep 2017 19:52:27 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-2.html</guid><description>1. 基本概念 Dockerfile 是一些列构建 Docker 镜像的指令集合。Docker 通过读取 Dockerfile 指令自动构建镜像。Dockerfile 类似于 Makefile，都是一种文本文件，按照构建镜像顺序组织所有的指令。 Docker 镜像的构建命令： 1 docker build . 这条命令中，Docker CLI 的处理流程如</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>服务</category><category>工具</category><category>Django</category></item><item><title>从零开始使用 Docker 打包 Django 开发环境 (1) 环境搭建</title><link>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-1.html</link><pubDate>Thu, 21 Sep 2017 09:38:47 +0000</pubDate><atom:modified>Thu, 21 Sep 2017 09:38:47 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-package-django-development-environments-using-docker-1.html</guid><description>Vagrant 适合用来管理虚拟机，而 Docker 适合用来管理应用环境。为了更好地模拟真实运行环境，本系列文章借助 Docker 和 Docker Compose 搭建 Nginx + uWSGI+ Django + MySQL + Redis + Rabbit 的开发环境。 1. 基本概念 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包应用以及依赖</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>服务</category><category>工具</category><category>Django</category></item><item><title>基于 Docker 的 Django 应用性能测试</title><link>https://www.chenshaowen.com/blog/django-application-performance-test-based-on-docker.html</link><pubDate>Thu, 07 Sep 2017 19:08:09 +0000</pubDate><atom:modified>Thu, 07 Sep 2017 19:08:09 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-application-performance-test-based-on-docker.html</guid><description>1. 网站性能基础指标 并发数： 服务器单位时间内处理的会话数量 吞吐率： 服务器单位时间内处理的请求数 响应时间： 用户从发出请求到接受完响应之间的总耗时，由网络传输耗时、服务处理耗时等多个部分组成 平均响应时间： 所有请求响应时间的平均值 2. 测试工具 性能测试</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>测试</category><category>Demo</category><category>Docker</category><category>Django</category></item><item><title>Django 初始化数据之 fixture</title><link>https://www.chenshaowen.com/blog/django-initializes-fixture-of-data.html</link><pubDate>Mon, 07 Aug 2017 21:57:43 +0000</pubDate><atom:modified>Mon, 07 Aug 2017 21:57:43 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-initializes-fixture-of-data.html</guid><description>1. Fixtures 特点 Fixtures 是一种新的提供初始化数据的方法，并且被 Django 的测试框架用来处理单元测试的测试数据。不同于 SQL 文件的是，使用 fixture 可以提供一个被 Django 的 serialization 系统所能识别的序列化文件，它会被读取并自动转换成对应的 model ，然后保存进数据库。 2. 数据导出 将 app_name 的数据导出为 ini</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据</category><category>初始化</category></item><item><title>Django Forms 功能</title><link>https://www.chenshaowen.com/blog/django-forms-function.html</link><pubDate>Fri, 21 Jul 2017 21:29:40 +0000</pubDate><atom:modified>Fri, 21 Jul 2017 21:29:40 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-forms-function.html</guid><description>1. 自动生成HTML表单元素 Widget，用来渲染成HTML元素的工具。 指定小部件 1 2 3 4 5 6 from django import forms class CommentForm(forms.Form): name = forms.CharField() url = forms.URLField() comment = forms.CharField(widget=forms.Textarea) CommentForm().as_table() 输出值 1 &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;&amp;lt;label for=&amp;#34;id_name&amp;#34;&amp;gt;Name:&amp;lt;/label&amp;gt;&amp;lt;/th&amp;gt;&amp;lt;td&amp;gt;&amp;lt;input id=&amp;#34;id_name&amp;#34; name=&amp;#34;name&amp;#34; type=&amp;#34;text&amp;#34; /&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;&amp;lt;label for=&amp;#34;id_url&amp;#34;&amp;gt;Url:&amp;lt;/label&amp;gt;&amp;lt;/th&amp;gt;&amp;lt;td&amp;gt;&amp;lt;input id=&amp;#34;id_url&amp;#34; name=&amp;#34;url&amp;#34; type=&amp;#34;url&amp;#34; /&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;&amp;lt;label for=&amp;#34;id_comment&amp;#34;&amp;gt;Comment:&amp;lt;/label&amp;gt;&amp;lt;/th&amp;gt;&amp;lt;td&amp;gt;&amp;lt;textarea cols=&amp;#34;40&amp;#34; id=&amp;#34;id_comment&amp;#34; name=&amp;#34;comment&amp;#34; rows=&amp;#34;10&amp;#34;&amp;gt;\r\n&amp;lt;/textarea&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; 指定表单字段为 Textarea 小部件，而不是默认的 TextInput 小部件。 自定义小部件的样式 1 2 3 4 class CommentFormClass(forms.Form):</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>安全</category></item><item><title>Django ORM 之 SQL</title><link>https://www.chenshaowen.com/blog/sql-code-about-django-orm.html</link><pubDate>Fri, 21 Jul 2017 13:21:08 +0000</pubDate><atom:modified>Fri, 21 Jul 2017 13:21:08 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/sql-code-about-django-orm.html</guid><description>1. 基本概念 ORM：对象关系映射，Object Relational Mapping。它的作用是在关系型数据库和对象之间作一个映射。不需要复杂的 SQL 语句，操作数据如同操作对象一样简单。 QuerySet：给定模型的对象列表。QuerySet 允许从数据库中读取数据，对其</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据</category><category>Demo</category><category>SQL</category></item><item><title>Haystack 全文检索</title><link>https://www.chenshaowen.com/blog/haystack-full-text-search.html</link><pubDate>Fri, 21 Jul 2017 13:00:03 +0000</pubDate><atom:modified>Fri, 21 Jul 2017 13:00:03 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/haystack-full-text-search.html</guid><description>简单介绍一下项目需求: 项目组需要对外发布文档，文档撰写使用的是Markdown，对外需要使用HTML。起初，使用的是Nginx+Jekyll的解决方案。随着文档的增加，文档系统对搜索功能有了强烈的需求。笔者在另外一篇文章中有所讨论，但是这几</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据</category><category>方案</category><category>检索</category></item><item><title>Django 信号</title><link>https://www.chenshaowen.com/blog/signal-of-django.html</link><pubDate>Thu, 13 Jul 2017 13:06:10 +0000</pubDate><atom:modified>Thu, 13 Jul 2017 13:06:10 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/signal-of-django.html</guid><description>1. 基本概念 Django内置了一个信号分发器。信号可以帮助解耦程序模块。在应用中其他地方发生某事件时，通知指定函数。信号允许某些 senders 通知一组 receivers 已经发生的行为。 2. 信号使用 2.1 声明信号 在使用信号之前，首先得创建信号实例，声明信号的接收参数列表。dja</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>后端</category><category>Python</category></item><item><title>Django 类视图</title><link>https://www.chenshaowen.com/blog/class-based-view-of-django.html</link><pubDate>Tue, 11 Jul 2017 16:36:56 +0000</pubDate><atom:modified>Tue, 11 Jul 2017 16:36:56 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/class-based-view-of-django.html</guid><description>Django中有两种视图，一种是函数式视图，另一种是类视图。视图的作用主要是，用于填充逻辑，返回响应体。函数式视图难以扩展，代码复用率低。而类视图可以利用继承、Mixins，快速复用、扩展功能。本文主要讨论了，Django对类视图的处理逻辑</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>后端</category><category>Python</category><category>类视图</category></item><item><title>Django自动化测试</title><link>https://www.chenshaowen.com/blog/auto-testing-of-django.html</link><pubDate>Mon, 10 Jul 2017 21:39:27 +0000</pubDate><atom:modified>Mon, 10 Jul 2017 21:39:27 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/auto-testing-of-django.html</guid><description>Django中写自动化测试可以使用：doctests或unit tests。自动化测试的逻辑是，将测试数据传入待测试函数，执行后，以输出结果与预期是否一致，作为判断测试是否通过的标准。这里有几个关键点，（1）需要测试数据，（2）需要指明待测试</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>测试</category><category>Demo</category><category>DevOps</category><category>CICD</category></item><item><title>Django REST Framework 权限管理</title><link>https://www.chenshaowen.com/blog/permissions-of-django-rest-framework.html</link><pubDate>Fri, 07 Jul 2017 06:47:19 +0000</pubDate><atom:modified>Fri, 07 Jul 2017 06:47:19 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/permissions-of-django-rest-framework.html</guid><description>1. DRF的权限管理 Django REST Framework的权限管理包括两个部分。 一个是认证Authentication方式。指定对用户进行鉴权的方式，获取request.user。 一个是权限控制Permissions。针对Django资源、用户类别进行权限</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>后端</category><category>安全</category><category>API</category><category>权限</category></item><item><title>Django 第三方组件 List</title><link>https://www.chenshaowen.com/blog/third-party-component-list-of-django.html</link><pubDate>Thu, 06 Jul 2017 09:27:50 +0000</pubDate><atom:modified>Thu, 06 Jul 2017 09:27:50 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/third-party-component-list-of-django.html</guid><description>Awesome-Django Django应用、项目和资源集合 Django-Packages 大量Django第三方组件。 Django-Mptt 在数据库中存储层级数据结构。 Django-Rest-Framework 自动生成 RESTful API。 Django-Rest-Framework-Jwt 为Django-Rest-Framework提供Token鉴权。 Django-Tastypie 自动生成 RESTful API。 Django-Cors-Headers 解决跨域访问的问题。 Django-Ckeditor Django富文</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Django</category><category>后端</category><category>组件</category></item><item><title>Django 模板继承</title><link>https://www.chenshaowen.com/blog/django-template-inherit.html</link><pubDate>Mon, 03 Jul 2017 19:17:11 +0000</pubDate><atom:modified>Mon, 03 Jul 2017 19:17:11 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-template-inherit.html</guid><description>1. 场景 在一个项目中，header、footer等元素经常被重复使用。为了避免，每个页面重写这些元素，同时，在修改时，不用去每个页面修改，需要将公共的部分抽离出来，这就是Django模板继承。 2. Django的复用模板标签 Django内建的复用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>模板</category></item><item><title>Django 装饰器</title><link>https://www.chenshaowen.com/blog/django-decorator.html</link><pubDate>Thu, 22 Jun 2017 23:55:59 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:55:59 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-decorator.html</guid><description>在前后端分离开发过程中，提供给前端的 API 接口，有的使用 GET 请求，有的使用 POST 请求。为了避免，后端在 views.py 的 request 中取值报错，需要在每个 view 函数中判断请求头的方法。于是，提取了一个公共的函数放在 utils.py 中，以便 view 函数引用。使用时依然繁琐，最后，在 Django 文档中找到了re</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>装饰器</category><category>Python</category></item><item><title>Django Snippets</title><link>https://www.chenshaowen.com/blog/snippets-of-django.html</link><pubDate>Thu, 22 Jun 2017 23:52:06 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:52:06 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/snippets-of-django.html</guid><description>1. Admin 自动注册全部 Model 字段 admin.py 1 2 3 4 5 6 7 8 9 10 # -*- coding: utf-8 -*- import inspect from django.contrib import admin from . import models for name, obj in inspect.getmembers(models): try: if inspect.isclass(obj): admin.site.register(getattr(models, name)) except Exception as e: pass 2. 获取全部 View Name 获取 Project 全部 View Name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.conf import settings from django.core.urlresolvers import RegexURLResolver, RegexURLPattern root_urlconf = __import__(settings.ROOT_URLCONF) all_urlpatterns = root_urlconf.urlpatterns VIEW_NAMES = [] # maintain a global list def get_all_view_names(urlpatterns): global VIEW_NAMES for pattern in urlpatterns: if isinstance(pattern, RegexURLResolver): get_all_view_names(pattern.url_patterns) #</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category></item><item><title>Django REST Framework 入门</title><link>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</link><pubDate>Thu, 22 Jun 2017 23:50:15 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:50:15 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</guid><description>笔者从事的SaaS开发，对开发效率有着比较高的要求。从项目立项、原型设计评估、需求确定、前端设计、后台开发到最后的验收，几个星期完成一次迭代。在敏捷开发的指导下，开始推行前后端分离模式。前端专注于页面和交互，后端专注于API接口。后端提供A</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据</category><category>后端</category><category>接口</category><category>Django</category><category>API</category></item><item><title>Apidoc 实践和自动化生成</title><link>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</link><pubDate>Wed, 14 Jun 2017 17:22:45 +0000</pubDate><atom:modified>Wed, 14 Jun 2017 17:22:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</guid><description>在前后端分离框架中，API 文档频繁交接。如果涉及到第三方接口调用，多方合作场景下，API 和文档变更可能会更快。为了方便维护 API 和交接文档，这里给大家推荐一款文档生成工具 - apidoc 1.apidoc 简介 apidoc 是一个基于 nodejs 的 API 文档生成工具，从代码注释中提取特定格式的内容，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>文档</category><category>研发</category></item><item><title>Django Restful 接口之 Tastypie</title><link>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</link><pubDate>Tue, 13 Jun 2017 21:31:13 +0000</pubDate><atom:modified>Tue, 13 Jun 2017 21:31:13 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</guid><description>1. Restful REST，是Representational State Transfer的缩写，表现层状态转化。Restful，是一种开发理念，万维网软件架构风格。 1.1 Restful特点 抽象资源 图片、文本、歌曲、视频都是一种资源实体，在网络上，被抽象为资源。在Re</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>Tastypie</category></item><item><title>Web开发中快速导出Excel文件(附代码)</title><link>https://www.chenshaowen.com/blog/how-to-export-excel-quickly-in-web-development.html</link><pubDate>Thu, 18 May 2017 17:51:05 +0000</pubDate><atom:modified>Thu, 18 May 2017 17:51:05 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-export-excel-quickly-in-web-development.html</guid><description>在Web开发中，常会遇到数据导出的需求。这篇主要介绍如何快速将数据导出，并保存为Excel文件。 1. 前端 Web开发中，格式化数据常以table的形式展示。下面是一个人员薪酬信息表，以导出这份数据为例。 姓名 职位 年龄 薪水 Tiger NixonTiger Nixon System Architect 61 $320,800 Garrett Winters Accountant 63 $170,750 Ashton</description><dc:creator>微信公众号</dc:creator><category>Django</category><category>前端</category><category>数据</category><category>Demo</category><category>博文</category></item><item><title>Django 中的 manage 命令</title><link>https://www.chenshaowen.com/blog/manage-command-in-django.html</link><pubDate>Mon, 15 May 2017 21:14:48 +0000</pubDate><atom:modified>Mon, 15 May 2017 21:14:48 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/manage-command-in-django.html</guid><description>每个Django项目中都会自动生成一个manage.py文件。manage.py是对django-admin的一个简单包装，其功能是将Django Project放到sys.path目录中，设置 DJANGO_SETTINGS_MODULE 环境变量为当前Project的setting.</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Django</category><category>工具</category><category>命令</category></item><item><title>Django Model 中的 Meta 选项</title><link>https://www.chenshaowen.com/blog/django-model-meta.html</link><pubDate>Thu, 11 May 2017 15:48:41 +0000</pubDate><atom:modified>Thu, 11 May 2017 15:48:41 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-model-meta.html</guid><description>通过一个内嵌类“class Meta”给model定义元数据，类似下面这样： 1 2 3 4 class Foo(models.Model): bar = models.CharField(max_length=30) class Meta: #...... Model元数据就是：不是一个字段的任何数据 比如排序选项，admin选项等等。 下面是所有可能用到的 Meta 选项。没有一个选项是必需的。 是否添加 class Meta 到</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Django</category><category>数据库</category><category>Model</category></item><item><title>Django 中间件</title><link>https://www.chenshaowen.com/blog/django-middleware.html</link><pubDate>Wed, 10 May 2017 19:39:12 +0000</pubDate><atom:modified>Wed, 10 May 2017 19:39:12 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-middleware.html</guid><description>1. __init__(self) 在中间件类中， __init__() 方法用于执行系统范围的初始化设置。 出于性能的考虑，每个已启用的中间件在每个服务器进程中只初始化一次。 也就是说 __init__() 仅在服务进程启动的时候调用，而在针对单个request处理时并不执行。 对一个middleware而言，定义 __init__() 方</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Django</category><category>Python</category><category>中间件</category></item><item><title>Django 标准库介绍</title><link>https://www.chenshaowen.com/blog/introduction-of-django-standard-library.html</link><pubDate>Wed, 10 May 2017 19:22:23 +0000</pubDate><atom:modified>Wed, 10 May 2017 19:22:23 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/introduction-of-django-standard-library.html</guid><description>Django的标准库存放在 django.contrib 包中。每个子包都是一个独立的附加功能包。 这些子包一般是互相独立的，不过有些django.contrib子包需要依赖其他子包 在 django.contrib 中对函数的类型并没有强制要求 。其中一些包中带有模型（因此需要你在数据库中安装对应的数据</description><dc:creator>微信公众号</dc:creator><category>Django</category><category>整理</category></item><item><title>构建可重用的Django App</title><link>https://www.chenshaowen.com/blog/how-to-build-reusable-django-app.html</link><pubDate>Fri, 05 May 2017 21:43:47 +0000</pubDate><atom:modified>Fri, 05 May 2017 21:43:47 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-build-reusable-django-app.html</guid><description>笔者所在的小组负责SaaS开发，几乎承载了中心的全部SaaS需求。其中，有长期维护的重点项目，也有短期突击的演示项目，每个人都身兼数职。当然，开发平台也开放给其他人员使用，整个平台有着成百上千的SaaS应用。这些应用中存在大量重复的功能块，</description><dc:creator>微信公众号</dc:creator><category>Django</category><category>管理</category><category>博文</category></item><item><title>Django的权限控制</title><link>https://www.chenshaowen.com/blog/django-permissions-control.html</link><pubDate>Sun, 22 Jan 2017 09:23:45 +0000</pubDate><atom:modified>Sun, 22 Jan 2017 09:23:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-permissions-control.html</guid><description>1. Django内置权限管理 1.1 权限分类 Permission 用来定义用户User A对任务Task的权限。 User 如果User A 对Model B有权限，那么User A 对Mode B中的全部实例都有相应权限。User对象的user_permission 字段用于管理用户的权限。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>开发</category><category>权限</category><category>Python</category></item><item><title>Django-数据迁移的几种方法(附代码)</title><link>https://www.chenshaowen.com/blog/several-methods-of-django-data-migration.html</link><pubDate>Tue, 17 Jan 2017 23:29:15 +0000</pubDate><atom:modified>Tue, 17 Jan 2017 23:29:15 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/several-methods-of-django-data-migration.html</guid><description>1. 背景 在Web开发的过程当中，常会涉及多个环境（本地、测试、正式环境）之间数据的迁移。本文主要探讨在django开发过程中，可能涉及的数据迁移路径，并寻找可行的方法。 2. 场景 数据迁移对象，一共分为四个：测试环境数据库、正式环境数据库、本地开发</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据</category><category>迁移</category></item><item><title>Django 浅析与工程目录结构实践</title><link>https://www.chenshaowen.com/blog/best-file-structure-of-django.html</link><pubDate>Sun, 01 Jan 2017 15:07:01 +0000</pubDate><atom:modified>Sun, 01 Jan 2017 15:07:01 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/best-file-structure-of-django.html</guid><description>1. Django是什么 Django是一套由Python完成的Web开发框架，起初被开发者用于管理以新闻内容为主的网站，2005年7月在BSD许可证发布下开源，2008年6月17日正式成立基金会。与Django一起的Python Web框架还有，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Python</category></item><item><title>Django 中 Celery 的应用</title><link>https://www.chenshaowen.com/blog/using-celery-in-django.html</link><pubDate>Tue, 25 Oct 2016 07:57:59 +0000</pubDate><atom:modified>Tue, 25 Oct 2016 07:57:59 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-celery-in-django.html</guid><description>场景一:公司准备给全部员工推送一个邮件公告。采用封装的邮件库API，使用一次循环遍历全部员工推送邮件，会使主程序卡在循环处无法响应，这是我们不愿意看到的，我们希望点击执行之后，可以正常其他操作。场景二，量化程序的本地回测数据库每天都要更新。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Celery</category><category>Django</category><category>博文</category></item></channel></rss>