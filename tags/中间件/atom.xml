<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>中间件 on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><description>Recent content in 中间件 on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Sat, 23 Dec 2017 20:51:22 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/atom.xml" rel="self" type="application/rss+xml"/><item><title>RabbitMQ 消息队列</title><link>https://www.chenshaowen.com/blog/message-queue-about-rabbitmq.html</link><pubDate>Sat, 23 Dec 2017 20:51:22 +0000</pubDate><atom:modified>Sat, 23 Dec 2017 20:51:22 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/message-queue-about-rabbitmq.html</guid><description>1. 消息队列的适用场景 1.1 异步处理 应用场景：用户注册后，需要发注册邮件和注册短信。同步的处理方法，系统的性能（并发量，吞吐量，响应时间）会有瓶颈。 1.2 应用解耦 应用场景：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>RabbitMQ</category><category>中间件</category><category>Celery</category><category>消息</category><category>队列</category></item><item><title>错误码设计以及 Django 的异常统一处理</title><link>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</link><pubDate>Mon, 30 Oct 2017 21:50:33 +0000</pubDate><atom:modified>Mon, 30 Oct 2017 21:50:33 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</guid><description>笔者目前使用 Django 从事 SaaS 开发，同时开发和维护多个 SaaS 应用。在很多 SaaS 应用中都约定了错误码，有的用于处理登录态，有的用于标记业务逻辑状态。对于这种项目共性很强的特征，花时间学习和研究是非常有必要的。本篇主要讨论了错误码的用途、如何设计错误码、使用 Django 中</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>错误码</category><category>中间件</category></item><item><title>Django 中间件</title><link>https://www.chenshaowen.com/blog/django-middleware.html</link><pubDate>Wed, 10 May 2017 19:39:12 +0000</pubDate><atom:modified>Wed, 10 May 2017 19:39:12 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-middleware.html</guid><description>1. __init__(self) 在中间件类中， __init__() 方法用于执行系统范围的初始化设置。 出于性能的考虑，每个已启用的中间件在每个服务器进程中只初始化一次。 也就是说 __init__() 仅在服务进程启动的时候调用，而在针对单个request处理时并不执行。 对一个middleware而言，定义 __init__() 方</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Django</category><category>Python</category><category>中间件</category></item></channel></rss>