<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>接口 on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/%E6%8E%A5%E5%8F%A3/</link><description>Recent content in 接口 on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Thu, 07 Dec 2023 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/%E6%8E%A5%E5%8F%A3/atom.xml" rel="self" type="application/rss+xml"/><item><title>我的 Restful API 规范</title><link>https://www.chenshaowen.com/blog/my-restful-api-specification.html</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate><atom:modified>Thu, 07 Dec 2023 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/my-restful-api-specification.html</guid><description>主要用来规范自己写的 API，也是为了让 LLM 更好理解我的 API。 1. Domain 尽量单独使用一个域名，例如 api.example.com 。 2. Path 统一使用小写字母。 不用包含 /api 前缀。 不要包含扩展名。 / 不要出现在末尾。 对于 Restful API，/ 用来划分资源层级，末尾的 / 会导致混淆。 使用带版本的路径 /v1 。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>接口</category><category>API</category><category>研发</category><category>规范</category></item><item><title>restframework 中 Serializer 和 ViewSet 的 API</title><link>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</link><pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 20 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</guid><description>1. Serializer 1.1 数据校验 在反序列化数据时，需要对数据的合法性进行校验。这时，可以调用 is_valid() 进行验证，如果发生验证错误，可以在 .errors 属性获取错误提示信息。例如： 1 2 3 4 serializer.is_valid() # False serializer.errors # {&amp;#39;created&amp;#39;: [u&amp;#39;This field is required.&amp;#39;]} .is_valid() 方法带有一个可选的 raise_exception 标志，如果存在验证错误，将抛出 serializers.ValidationError 异常。 1 serializer.is_valid(raise_exception=True) 除了使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>接口</category></item><item><title>restframework 中的 Viewset 和 Serializer</title><link>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</link><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Sun, 18 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</guid><description>1. Django 中的 View Class 首先回忆一下，Django 对请求的处理逻辑。收到一次请求之后，Django 会生成一个 WSGIHandler 类型的 handler，由 handler 控制整个处理流程。 那么，请求的 URL 与 View 是如何关联的呢？ Django 首先根据 ROOT_URLCONF 的配置加载 URLconf，按顺序逐个匹配 URLconf 的 URLp</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>框架</category><category>接口</category></item><item><title>Vue 中使用 axios</title><link>https://www.chenshaowen.com/blog/using-axios-in-vue.html</link><pubDate>Mon, 25 Jun 2018 15:00:00 +0000</pubDate><atom:modified>Mon, 25 Jun 2018 15:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-axios-in-vue.html</guid><description>1. axios 安装 使用 npm 安装 1 npm install axios --save 全局注册有两种方法： 绑定到原型上 1 2 import axios from &amp;#39;axios&amp;#39; Vue.prototype.axios = axios 这种方法，每个 Vue 对象都会新增一个 axios 对象。 1 2 3 this.axios.post(apiUrl).then((res) =&amp;gt; { //do something }) 挂载到 windows 对象上 在 DOM 的任意地方，都能使用 axios 函数。 1 2 import axios from &amp;#39;axios&amp;#39; window.axios = axios; 1 2 3 axios.post(apiUrl).then((res) =&amp;gt; { //do something }) 2. axios 配置 为了配合 Django 的 CSRF</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>前端</category><category>接口</category><category>API</category><category>Vuejs</category><category>Axios</category></item><item><title>后端服务之接口流量控制</title><link>https://www.chenshaowen.com/blog/rate-limiting-of-api.html</link><pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate><atom:modified>Thu, 11 Jan 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/rate-limiting-of-api.html</guid><description>1. 流控 缓存、降级和限流是保护高并发系统的常用方法。缓存以空间换时间、减少了 CPU 和网络调用的耗时；降级保护了核心服务的高可用，高峰时段延时或拒绝处理非核心请求；限流是通过限制并发请求来保护系统。 限流就是，在有限资源的情况下，每个 API 接口单位时间内</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>接口</category><category>微服务</category></item><item><title>HTTP Header 之 Content-Type</title><link>https://www.chenshaowen.com/blog/content-type-http-header.html</link><pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate><atom:modified>Sat, 30 Dec 2017 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/content-type-http-header.html</guid><description>1. HTTP Header HTTP 协议是建立在 TCP/IP 协议之上的应用层规范，以 ASCII 码传输。HTTP 规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 1 2 3 4 5 &amp;lt;method&amp;gt;&amp;lt;request-URL&amp;gt;&amp;lt;version&amp;gt; &amp;lt;headers&amp;gt; &amp;lt;entity-body&amp;gt; HTTP Header 包括通用头、请求头、响应头和实体头这四个部分。每个头域由一个头域的域名，冒号和域值组成。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>HTTP</category><category>接口</category></item><item><title>API 接口规范</title><link>https://www.chenshaowen.com/blog/api-interface-specification.html</link><pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate><atom:modified>Fri, 01 Dec 2017 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-interface-specification.html</guid><description>在 Web 应用开发的过程中，后端开发人员需要频繁的交付 API 接口，前端开发人员需要频繁的调用 API 接口。为了降低沟通成本、预防可能的安全风险，遵循约定优于配置的原则，有必要规范 API 的接口规范。Restful API 是以资源为核心的 API 设计思路，所有的操作都是针对特</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>研发</category><category>规范</category></item><item><title>Django REST Framework 入门</title><link>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</link><pubDate>Thu, 22 Jun 2017 23:50:15 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:50:15 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</guid><description>笔者从事的SaaS开发，对开发效率有着比较高的要求。从项目立项、原型设计评估、需求确定、前端设计、后台开发到最后的验收，几个星期完成一次迭代。在敏捷开发的指导下，开始推行前后端分离模式。前端专注于页面和交互，后端专注于API接口。后端提供A</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据</category><category>后端</category><category>接口</category><category>Django</category><category>API</category></item><item><title>Apidoc 实践和自动化生成</title><link>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</link><pubDate>Wed, 14 Jun 2017 17:22:45 +0000</pubDate><atom:modified>Wed, 14 Jun 2017 17:22:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</guid><description>在前后端分离框架中，API 文档频繁交接。如果涉及到第三方接口调用，多方合作场景下，API 和文档变更可能会更快。为了方便维护 API 和交接文档，这里给大家推荐一款文档生成工具 - apidoc 1.apidoc 简介 apidoc 是一个基于 nodejs 的 API 文档生成工具，从代码注释中提取特定格式的内容，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>文档</category><category>研发</category></item><item><title>Django Restful 接口之 Tastypie</title><link>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</link><pubDate>Tue, 13 Jun 2017 21:31:13 +0000</pubDate><atom:modified>Tue, 13 Jun 2017 21:31:13 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</guid><description>1. Restful REST，是Representational State Transfer的缩写，表现层状态转化。Restful，是一种开发理念，万维网软件架构风格。 1.1 Restful特点 抽象资源 图片、文本、歌曲、视频都是一种资源实体，在网络上，被抽象为资源。在Re</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>Tastypie</category></item></channel></rss>