<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>并发 on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Thu, 03 Sep 2020 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/%E5%B9%B6%E5%8F%91/atom.xml" rel="self" type="application/rss+xml"/><item><title>一起来学 Go --（5）Goroutine 和 Channel</title><link>https://www.chenshaowen.com/blog/let-us-start-learning-go-5.html</link><pubDate>Thu, 03 Sep 2020 00:00:00 +0000</pubDate><atom:modified>Thu, 03 Sep 2020 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/let-us-start-learning-go-5.html</guid><description>1. Go 中的并发模型 1.1 通信模型 CSP CSP 全称 Communicating Sequential Process ，通信顺序进程，描述的是一种并发通信模型。Process 可以使用很多个 Channel ，而 Channel 不关心谁在使用它，只负责收发数据。 Go 社区中，有一句非常著名的论断: 不要通过共享内存来通信，要通过通信来共享内存。意思是，不</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Go</category><category>并发</category><category>并行</category><category>Goroutine</category><category>Channel</category><category>学习</category><category>一起来学Go</category></item><item><title>如何在 Django 中保证并发的数据一致性</title><link>https://www.chenshaowen.com/blog/how-to-ensure-concurrence-of-data-in-django.html</link><pubDate>Mon, 25 Jun 2018 12:00:00 +0000</pubDate><atom:modified>Mon, 25 Jun 2018 12:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-ensure-concurrence-of-data-in-django.html</guid><description>前面一部分主要讲乐观锁和悲观锁。锁从数据库层面，保证了并发时的数据一致性。了解锁，有助于对并发解决方案的理解。后面一部分主要讲的是 Django 中，并发场景下，保证数据一致性的解决办法。 1. 关于锁 1.1 乐观锁 乐观锁的出发点是，同一条数据很少会因为并发修改而产</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>并发</category></item><item><title>Python 中的进程、线程、协程</title><link>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</link><pubDate>Sat, 06 Jan 2018 11:22:55 +0000</pubDate><atom:modified>Sat, 06 Jan 2018 11:22:55 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</guid><description>1. 进程 进程是正在运行的程序实例，是内核分配资源的最基本的单元。进程拥有自己独立的堆和栈，独立的地址空间，资源句柄。进程由 OS 调度，调度开销较大，在并发的切换过程效率较低。 Python 提供了一个跨平台的多进程模块 multiprocessing，模块中使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>并发</category></item></channel></rss>