<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>demo on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/demo/</link><description>Recent content in demo on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Wed, 20 Jan 2021 01:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/demo/atom.xml" rel="self" type="application/rss+xml"/><item><title>不限次数，单次最长 6 小时免费在线体验 Kubernetes</title><link>https://www.chenshaowen.com/blog/free-kubernetes-env-using-github-actions.html</link><pubDate>Wed, 20 Jan 2021 01:00:00 +0000</pubDate><atom:modified>Wed, 20 Jan 2021 01:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/free-kubernetes-env-using-github-actions.html</guid><description>1. 登录 Ngrok 获取一个 Authtoken 1.1 登陆 Ngrok 官网，获取 Authtoken 访问 Ngrok 官网，https://dashboard.ngrok.com/ , 可以使用 GitHub 或者 Google 账户登陆。 进入 Authentication 页面，找到自己的 Authtoken，如下图: 1.2 在 GitHub 项目下，配置 Secrets 在项目的 Settings 页面中，新增 Secrets</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>GitHub</category><category>Actions</category><category>DevOps</category><category>CICD</category><category>demo</category></item><item><title>debugger-action 更新 v2 版支持 ngrok</title><link>https://www.chenshaowen.com/blog/a-debugger-for-actions-v2.html</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><atom:modified>Wed, 20 Jan 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/a-debugger-for-actions-v2.html</guid><description>1. 什么是 Ngrok Ngrok 是一个内网穿透工具，能够将内网的服务，发布到公网上。下面这张图，可以很好地展示其功能: 相较于同类工具 Frp (需要同时运行 Server 和 Client )，Ngrok 将内网穿透做成了一个服务。只需要在 Ngrok 注册账户，获得 Authtoken ，启动 Client 就可以对外提供，本地服务的公网地</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>GitHub</category><category>Actions</category><category>DevOps</category><category>CICD</category><category>demo</category></item><item><title>GitHub Actions 在线调试工具：debugger-action</title><link>https://www.chenshaowen.com/blog/a-debugger-for-actions.html</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><atom:modified>Mon, 18 Jan 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/a-debugger-for-actions.html</guid><description>1. Debug 到想跑路 GitHub Actions 是 GitHub 在 2018 年 10 月推出的持续集成服务。对于开源项目，免费提供无限时长的构建时间，同时支持 Linux、MacOs、Windows 系统，非常招人喜爱。 但是，最近的一次经历改变了我的看法。我给同事的仓库，提交了一个 improvement: build and ci 的 commit ，用于完</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>GitHub</category><category>Actions</category><category>DevOps</category><category>CICD</category><category>demo</category></item><item><title>在 Kubernetes 中如何获取客户端真实 IP</title><link>https://www.chenshaowen.com/blog/how-to-get-the-real-ip-of-client-in-kubernetes.html</link><pubDate>Fri, 20 Nov 2020 17:22:45 +0000</pubDate><atom:modified>Fri, 20 Nov 2020 17:22:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-get-the-real-ip-of-client-in-kubernetes.html</guid><description>Kubernetes 依靠 kube-proxy 组件实现 Service 的通信与负载均衡。在这个过程中，由于使用了 SNAT 对源地址进行了转换，导致 Pod 中的服务拿不到真实的客户端 IP 地址信息。本篇主要解答了在 Kubernetes 集群中负载如何获取客户端真实 IP 地址这个问题。 1. 创建一个后端服务 1.1 服务选择 这里选择 containous/whoami 作为后端服务镜</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Kubernetes</category><category>IP</category><category>Demo</category></item><item><title>使用 frp 将本地服务发布到公网</title><link>https://www.chenshaowen.com/blog/using-frp-to-publish-local-service-to-public-network.html</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Wed, 07 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-frp-to-publish-local-service-to-public-network.html</guid><description>1. 什么是 frp frp 是一个高性能的反向代理应用，提供的功能有： 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务 对于 http、https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个 80 端口 利用处于内网或防火墙后的机器，对</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>FRP</category><category>Demo</category><category>工具</category></item><item><title>如何使用 Django Signal 解耦模块</title><link>https://www.chenshaowen.com/blog/how-to-use-django-signal-decoupling-module.html</link><pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate><atom:modified>Fri, 12 Oct 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-django-signal-decoupling-module.html</guid><description>最近，我负责开发一个重后端的应用。这个应用数据流向复杂，处理逻辑冗余堆积。项目技术栈选择的是 Django + Vuejs。前端使用 Webpack 打包，模块化管理，主要是展示数据。后端涉及的模块多，处理规则多，数据表多，每次涉及之前功能修改时，都消耗大量时间 review 代码。这</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>设计</category><category>解耦</category><category>Demo</category></item><item><title>有意思的游戏</title><link>https://www.chenshaowen.com/blog/interesting-games.html</link><pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 04 Sep 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/interesting-games.html</guid><description>切水果 牛顿摆 汤姆猫</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Demo</category><category>游戏</category></item><item><title>使用 CloudReady 制作 Chrome OS 安装启动盘</title><link>https://www.chenshaowen.com/blog/how-to-use-cloudready-make-chrome-os-boot-disk.html</link><pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate><atom:modified>Sat, 18 Aug 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-cloudready-make-chrome-os-boot-disk.html</guid><description>1. 下载镜像文件 点击进入，CloudReady 官网下载 DOWNLOAD 64-BIT 或 DOWNLOAD 32-BIT 版本镜像。解压后，得到 cloudready-free-xxx-bit.bin 文件 2. 安装 Chromebook 恢复工具 首先需要安装 Chrome 浏览器，然后打开页面，安装 Chromebook Recovery Utility。 3. 制作镜像 第一步，打开 Chromebook Recovery Utility 第二步，选择 Use local image，再选择刚才解压出来</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Demo</category><category>系统</category><category>浏览器</category><category>CloudReady</category></item><item><title>如何在 Django 中任意安全获取 request</title><link>https://www.chenshaowen.com/blog/how-to-secure-get-request-in-django.html</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 26 Jun 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-secure-get-request-in-django.html</guid><description>在 Django 中，request 包含了一次请求的全部信息。后端处理逻辑经常需要用到 request 中的信息。比如， DRF 框架中想要随时能够获取到 request，或者将一些参数全局传递。Django 第三方 App 中有一些工具可以满足要求，但它们并不是安全可靠的。意思是，如果 Django</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category></item><item><title>Python 中的进程、线程、协程</title><link>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</link><pubDate>Sat, 06 Jan 2018 11:22:55 +0000</pubDate><atom:modified>Sat, 06 Jan 2018 11:22:55 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/process-and-thread-in-python.html</guid><description>1. 进程 进程是正在运行的程序实例，是内核分配资源的最基本的单元。进程拥有自己独立的堆和栈，独立的地址空间，资源句柄。进程由 OS 调度，调度开销较大，在并发的切换过程效率较低。 Python 提供了一个跨平台的多进程模块 multiprocessing，模块中使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>并发</category></item><item><title>错误码设计以及 Django 的异常统一处理</title><link>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</link><pubDate>Mon, 30 Oct 2017 21:50:33 +0000</pubDate><atom:modified>Mon, 30 Oct 2017 21:50:33 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/error-code-design-and-unified-processing-in-django.html</guid><description>笔者目前使用 Django 从事 SaaS 开发，同时开发和维护多个 SaaS 应用。在很多 SaaS 应用中都约定了错误码，有的用于处理登录态，有的用于标记业务逻辑状态。对于这种项目共性很强的特征，花时间学习和研究是非常有必要的。本篇主要讨论了错误码的用途、如何设计错误码、使用 Django 中</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>错误码</category><category>中间件</category></item><item><title>Django 大文件传输</title><link>https://www.chenshaowen.com/blog/django-big-file-transfer.html</link><pubDate>Tue, 26 Sep 2017 18:28:56 +0000</pubDate><atom:modified>Tue, 26 Sep 2017 18:28:56 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-big-file-transfer.html</guid><description>1. 直接返回文件 如果静态文件在工程根目录的 media/test.zip，需要先将文件读入内存，再进行传输。代码如下： settings.py 配置 1 2 PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__)) MEDIA_ROOT = os.path.join(PROJECT_ROOT, &amp;#39;media/&amp;#39;) yourapp/views.py 1 2 3 4 5 6 7 8 9 10 11 12 from django.conf import settings from django.http import HttpResponse from django.core.files.storage import FileSystemStorage def download_file_direct_from_file(request): file_system = FileSystemStorage(settings.MEDIA_ROOT) file_name = &amp;#39;test.zip&amp;#39; with file_system.open(file_name) as f: response = HttpResponse(f) response[&amp;#39;Content-Type&amp;#39;] = &amp;#39;application/%s&amp;#39; % file_name.split(&amp;#39;.&amp;#39;)[-1] response[&amp;#39;Content-Disposition&amp;#39;] = &amp;#39;attachment; filename=&amp;#34;%s&amp;#34;&amp;#39;% file_name return</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>Django</category><category>大文件</category><category>网络</category><category>Demo</category></item><item><title>基于 Docker 的 Django 应用性能测试</title><link>https://www.chenshaowen.com/blog/django-application-performance-test-based-on-docker.html</link><pubDate>Thu, 07 Sep 2017 19:08:09 +0000</pubDate><atom:modified>Thu, 07 Sep 2017 19:08:09 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-application-performance-test-based-on-docker.html</guid><description>1. 网站性能基础指标 并发数： 服务器单位时间内处理的会话数量 吞吐率： 服务器单位时间内处理的请求数 响应时间： 用户从发出请求到接受完响应之间的总耗时，由网络传输耗时、服务处理耗时等多个部分组成 平均响应时间： 所有请求响应时间的平均值 2. 测试工具 性能测试</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>测试</category><category>Demo</category><category>Docker</category><category>Django</category></item><item><title>GitLab 搭建与配置</title><link>https://www.chenshaowen.com/blog/build-and-configure-of-gitlab.html</link><pubDate>Sat, 12 Aug 2017 00:51:07 +0000</pubDate><atom:modified>Sat, 12 Aug 2017 00:51:07 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/build-and-configure-of-gitlab.html</guid><description>1. 简介 GitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现了自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。 它拥有与 GitHub 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Demo</category><category>工具</category><category>管理</category><category>持续集成</category><category>GitLab</category><category>DevOps</category></item><item><title>页面使用自定义字体</title><link>https://www.chenshaowen.com/blog/page-uses-a-custom-font.html</link><pubDate>Tue, 01 Aug 2017 19:30:47 +0000</pubDate><atom:modified>Tue, 01 Aug 2017 19:30:47 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/page-uses-a-custom-font.html</guid><description>1. Font-family 网页上能使用的字体，限制在浏览器所在PC已经安装的几款字体。 Windows操作系统，中文字体： 黑体：SimHei 宋体：SimSun 新宋体：NSimSun 仿宋：FangSong 楷体：KaiTi 仿宋GB2312：FangSongGB2312</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>前端</category><category>Demo</category></item><item><title>运营埋点与方案设计</title><link>https://www.chenshaowen.com/blog/operation-buried-point-and-design.html</link><pubDate>Fri, 21 Jul 2017 13:34:15 +0000</pubDate><atom:modified>Fri, 21 Jul 2017 13:34:15 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/operation-buried-point-and-design.html</guid><description>1. 名词解释 xpath ： 分为精确路径和概略路径两种做法。精确路径 ： body&amp;gt;div[0]&amp;gt;div[3]&amp;gt;ul&amp;gt;li[5]&amp;gt;a[0] ，从被点击的元素不断向上查找到根节点，并记录过程中每个节点。概略路径：body&amp;gt;div.header&amp;gt;div.nav&amp;gt;a[23]，在前者的基础上省略上溯路径中非白名</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据</category><category>设计</category><category>方案</category><category>Demo</category></item><item><title>Django ORM 之 SQL</title><link>https://www.chenshaowen.com/blog/sql-code-about-django-orm.html</link><pubDate>Fri, 21 Jul 2017 13:21:08 +0000</pubDate><atom:modified>Fri, 21 Jul 2017 13:21:08 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/sql-code-about-django-orm.html</guid><description>1. 基本概念 ORM：对象关系映射，Object Relational Mapping。它的作用是在关系型数据库和对象之间作一个映射。不需要复杂的 SQL 语句，操作数据如同操作对象一样简单。 QuerySet：给定模型的对象列表。QuerySet 允许从数据库中读取数据，对其</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>数据</category><category>Demo</category><category>SQL</category></item><item><title>Django自动化测试</title><link>https://www.chenshaowen.com/blog/auto-testing-of-django.html</link><pubDate>Mon, 10 Jul 2017 21:39:27 +0000</pubDate><atom:modified>Mon, 10 Jul 2017 21:39:27 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/auto-testing-of-django.html</guid><description>Django中写自动化测试可以使用：doctests或unit tests。自动化测试的逻辑是，将测试数据传入待测试函数，执行后，以输出结果与预期是否一致，作为判断测试是否通过的标准。这里有几个关键点，（1）需要测试数据，（2）需要指明待测试</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>测试</category><category>Demo</category><category>DevOps</category><category>CICD</category></item><item><title>Django 装饰器</title><link>https://www.chenshaowen.com/blog/django-decorator.html</link><pubDate>Thu, 22 Jun 2017 23:55:59 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:55:59 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/django-decorator.html</guid><description>在前后端分离开发过程中，提供给前端的 API 接口，有的使用 GET 请求，有的使用 POST 请求。为了避免，后端在 views.py 的 request 中取值报错，需要在每个 view 函数中判断请求头的方法。于是，提取了一个公共的函数放在 utils.py 中，以便 view 函数引用。使用时依然繁琐，最后，在 Django 文档中找到了re</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category><category>装饰器</category><category>Python</category></item><item><title>Django Snippets</title><link>https://www.chenshaowen.com/blog/snippets-of-django.html</link><pubDate>Thu, 22 Jun 2017 23:52:06 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:52:06 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/snippets-of-django.html</guid><description>1. Admin 自动注册全部 Model 字段 admin.py 1 2 3 4 5 6 7 8 9 10 # -*- coding: utf-8 -*- import inspect from django.contrib import admin from . import models for name, obj in inspect.getmembers(models): try: if inspect.isclass(obj): admin.site.register(getattr(models, name)) except Exception as e: pass 2. 获取全部 View Name 获取 Project 全部 View Name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.conf import settings from django.core.urlresolvers import RegexURLResolver, RegexURLPattern root_urlconf = __import__(settings.ROOT_URLCONF) all_urlpatterns = root_urlconf.urlpatterns VIEW_NAMES = [] # maintain a global list def get_all_view_names(urlpatterns): global VIEW_NAMES for pattern in urlpatterns: if isinstance(pattern, RegexURLResolver): get_all_view_names(pattern.url_patterns) #</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>Demo</category></item><item><title>用 Jekyll 搭建文档系统</title><link>https://www.chenshaowen.com/blog/how-to-develop-document-system-using-jekyll.html</link><pubDate>Sat, 17 Jun 2017 00:02:01 +0000</pubDate><atom:modified>Sat, 17 Jun 2017 00:02:01 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-develop-document-system-using-jekyll.html</guid><description>技术输出型公司，一套优秀的文档管理、发布系统必不可少。文档系统是内容管理系统的一种，其对可访问性要求高、单文档更新频率低、发布频率高。笔者认为，以纯静态HTML对外发布文档是个不错的选择。但是，直接写HTML文档，费时费力、不好维护。能不能</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Demo</category><category>设计</category></item><item><title>七牛存储批量操作 - qshell</title><link>https://www.chenshaowen.com/blog/qiniu-storage-batch-operation-using-qshell.html</link><pubDate>Sun, 21 May 2017 21:47:49 +0000</pubDate><atom:modified>Sun, 21 May 2017 21:47:49 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/qiniu-storage-batch-operation-using-qshell.html</guid><description>1. 下载工具 - qshell qshell 是利用七牛文档上公开的 API 实现的一个方便开发者测试和使用七牛API服务的命令行工具，使用 Go 语言编写而成。目前该工具融合了七牛存储， CDN ，以及其他的一些七牛服务中经常使用到的方法对应的便捷命令。 | 版本 | 支持平台 | 链接 | 更新日志 | |</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据</category><category>Demo</category><category>CDN</category><category>七牛</category><category>批量</category></item><item><title>Web开发中快速导出Excel文件(附代码)</title><link>https://www.chenshaowen.com/blog/how-to-export-excel-quickly-in-web-development.html</link><pubDate>Thu, 18 May 2017 17:51:05 +0000</pubDate><atom:modified>Thu, 18 May 2017 17:51:05 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-export-excel-quickly-in-web-development.html</guid><description>在Web开发中，常会遇到数据导出的需求。这篇主要介绍如何快速将数据导出，并保存为Excel文件。 1. 前端 Web开发中，格式化数据常以table的形式展示。下面是一个人员薪酬信息表，以导出这份数据为例。 姓名 职位 年龄 薪水 Tiger NixonTiger Nixon System Architect 61 $320,800 Garrett Winters Accountant 63 $170,750 Ashton</description><dc:creator>微信公众号</dc:creator><category>Django</category><category>前端</category><category>数据</category><category>Demo</category><category>博文</category></item><item><title>Python读写Excel</title><link>https://www.chenshaowen.com/blog/using-python-read-and-write-excel-data.html</link><pubDate>Sun, 16 Apr 2017 01:35:32 +0000</pubDate><atom:modified>Sun, 16 Apr 2017 01:35:32 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-python-read-and-write-excel-data.html</guid><description>Python、Excel常用于数据处理，难免会产生相互的数据传递、计算处理。本文主要介绍Python-Excel系列的库，以及xlrd和xlwt两个库是使用。 1. 常用库 xlwings，openpyxl，pandas，win32com，xlsx</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Demo</category><category>Python</category><category>数据</category></item><item><title>jQuery插件开发</title><link>https://www.chenshaowen.com/blog/plugin-development-of-jquery.html</link><pubDate>Sun, 05 Mar 2017 17:16:43 +0000</pubDate><atom:modified>Sun, 05 Mar 2017 17:16:43 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/plugin-development-of-jquery.html</guid><description>1. jQuery特征 jQuery消除了浏览器的兼容问题 遍历DOM树、选择元素 大量的插件库 工具函数库，$.type()、$.extent()等 jQuery的核心函数，通常指的是一个工厂对象，即jQuery()函数，或者更为常用的别名$()函数。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>前端</category><category>JavaScript</category><category>Demo</category></item><item><title>Python的反射：getattr</title><link>https://www.chenshaowen.com/blog/reflection-of-python.html</link><pubDate>Fri, 17 Feb 2017 20:46:34 +0000</pubDate><atom:modified>Fri, 17 Feb 2017 20:46:34 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/reflection-of-python.html</guid><description>1. 应用场景 通过配置文件，控制程序运行时的流程。配置文件中常保存的是，字符串，而不是对象 调试程序时，查看对象的全部属性值 动态模块的导入 对于第一种场景，广泛被采用的是反射。在Java的很多框架中都使用了反射机制，Python实现的Web框架Dj</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>Demo</category></item><item><title>使用 Python 绘制分形: Koch 曲线、Julia 集、Mandelbrot 集</title><link>https://www.chenshaowen.com/blog/drawing-2d-fractal-graph-using-python.html</link><pubDate>Wed, 25 Jan 2017 23:28:00 +0000</pubDate><atom:modified>Wed, 25 Jan 2017 23:28:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/drawing-2d-fractal-graph-using-python.html</guid><description>1. Koch曲线 瑞典数学家Helge von Koch，在1904年发表的“从初等几何构造的一条没有切线的连续曲线”的论文中提出Korch曲线。它的描述如下： 指定一条线段的长度\(l\)（可以理解为第0次迭代） 将这条线段三等分，并以中间的线段为底边构</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Python</category><category>数学</category><category>Demo</category></item></channel></rss>