<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>容器 on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/%E5%AE%B9%E5%99%A8/</link><description>Recent content in 容器 on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Sat, 16 Nov 2024 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/%E5%AE%B9%E5%99%A8/atom.xml" rel="self" type="application/rss+xml"/><item><title>使用 PyTorch 在 MNIST 数据集训练模型</title><link>https://www.chenshaowen.com/blog/using-pytorch-to-train-model-on-mnist-dataset.html</link><pubDate>Sat, 16 Nov 2024 00:00:00 +0000</pubDate><atom:modified>Sat, 16 Nov 2024 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-pytorch-to-train-model-on-mnist-dataset.html</guid><description>1. 创建训练脚本 创建训练脚本 mnist.py，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>AI</category><category>PyTorch</category><category>训练</category><category>容器</category></item><item><title>常用 AI 基础镜像及启动命令</title><link>https://www.chenshaowen.com/blog/common-ai-base-images-and-run-command.html</link><pubDate>Thu, 28 Mar 2024 00:01:00 +0000</pubDate><atom:modified>Thu, 28 Mar 2024 00:01:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/common-ai-base-images-and-run-command.html</guid><description>1. 镜像 Tag 标识的含义 base/cuda: 包括 CUDA 运行时 runtime: 在 base 的基础上，新增了 CUDA math 库和 NCCL、cuDNN 运行时 devel: 在 runtime 的基础上，新增了头文件和用于构建 CUDA 镜像的开发工具，对于多阶段构建特别有用 cuddn: 在上面基础上，新增了 cuDNN 神经网络加速库 py3: Python 3 环境 2. CUDA 镜像 镜像 AMD64 镜像大小 ARM64 镜</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>AI</category><category>镜像</category><category>容器</category></item><item><title>容器下的 Go 应用程序优化</title><link>https://www.chenshaowen.com/blog/optimization-go-applications-in-containers.html</link><pubDate>Sat, 11 Nov 2023 08:05:48 +0000</pubDate><atom:modified>Sat, 11 Nov 2023 08:05:48 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/optimization-go-applications-in-containers.html</guid><description>1. 内存对齐 结构体内字段，从大到小排列 减少内存占用 安装 fieldalignment 工具 1 go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest 分析并修复内存对齐 1 2 3 4 5 6 7 8 9 fieldalignment -fix ./... /Users/shaowenchen/Code/app/config/config.go:136:14: struct with 32 pointer bytes could be 24 /Users/shaowenchen/Code/app/config/config.go:150:11: struct of size 96 could be 88 /Users/shaowenchen/Code/app/config/config.go:166:14: struct of size 152 could be 144 /Users/shaowenchen/Code/app/config/config.go:194:12: struct with 80 pointer bytes could be 72 /Users/shaowenchen/Code/app/config/config.go:209:12: struct with 56 pointer bytes could be 40 /Users/shaowenchen/Code/app/dao/gormx/gorm.go:12:13: struct with 16 pointer bytes could be 8 /Users/shaowenchen/Code/app/dao/gormx/entity/cluster.go:5:14: struct with 128 pointer bytes could be 104 查看 fieldalignment 进行</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Go</category><category>性能优化</category><category>容器</category><category>最佳实践</category></item><item><title>Dockerfile 中 Run mv 比 cp 慢</title><link>https://www.chenshaowen.com/blog/run-mv-is-slower-than-cp-in-dockerfile.html</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><atom:modified>Mon, 30 Jan 2023 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/run-mv-is-slower-than-cp-in-dockerfile.html</guid><description>不同于 CentOS、Ubuntu，我们感受到 mv 比 cp 快；在使用 Dockerfile 构建镜像时，使用 Run cp 会比 Run mv 更快。本篇将给出相关的一些测试、验证的数据结果。 1. 测试准备 机器环境 Ubuntu 20.04.1 LTS 32C 125Gi 由于是生产机器，上面会有些负载，因此测试会有偏差。我会多次测试，等结果稳定</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>容器</category><category>CICD</category></item><item><title>在容器中使用 obsutil 命令问题</title><link>https://www.chenshaowen.com/blog/some-problems-using-obsutil-commands-in-containers.html</link><pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate><atom:modified>Fri, 15 Apr 2022 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/some-problems-using-obsutil-commands-in-containers.html</guid><description>1. 容器的 ulimit 设置太小 报错信息: 1 2 3 4 5 6 7 CheckpointDir: /root/.obsutil_checkpoint OutputDir: /root/.obsutil_output runtime: mlock of signal stack failed: 12 runtime: increase the mlock limit (ulimit -l) or runtime: update your kernel to 5.3.15+, 5.4.2+, or 5.5+ fatal error: mlock failed 如果是 Docker 下，可以在启动时添加 ulimit 参数 1 docker run -it --ulimit memlock=-1 ... 如果是 Kubernetes 下，需要以特权模式启动 Pod 1 2 3 securityContext: privileged: true runAsUser: 0 在 yaml 配置中添加上面的片段，然后在启动脚</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>对象存储</category><category>容器</category></item><item><title>Kubernetes 集群规划之规模与节点大小</title><link>https://www.chenshaowen.com/blog/the-scale-and-node-size-of-kubernetes-cluster.html</link><pubDate>Mon, 01 Nov 2021 10:00:00 +0000</pubDate><atom:modified>Mon, 01 Nov 2021 10:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/the-scale-and-node-size-of-kubernetes-cluster.html</guid><description>从调研数据来看，大家选择小集群的比较较高。下面是从节点数、节点配置角度提供的一份对比列表。 下面是选择少量大集群，还是多个小集群的对比列表: 特征 少量大集群 多个小集群 资源利用率 高 低 管理节点开销 低 高 资源伸缩范围 大 小 资源调度范围 大 小 应用间通信效率 高</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Harbor</category><category>镜像</category><category>容器</category></item><item><title>容器下的两地三中心建设</title><link>https://www.chenshaowen.com/blog/the-construction-of-two-places-and-three-centers-under-the-container.html</link><pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate><atom:modified>Sun, 10 Oct 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/the-construction-of-two-places-and-three-centers-under-the-container.html</guid><description>1. 关于两地三中心 如上图，两地三中心的架构，是为了提高系统的容错、容灾的能力。当一个数据中心不可用时，能够将关键业务的流量切换到其他数据中心，可以抵御城市级的自然灾害。 两地指的是，地理上不同的两座城市，而三中心指的是: 生产中心 同城灾备中心 异地</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>两地三中心</category><category>容器</category><category>Kubernetes</category></item><item><title>使用 Cilium 替换 Calico</title><link>https://www.chenshaowen.com/blog/how-to-use-cilium-to-replace-calico.html</link><pubDate>Thu, 16 Sep 2021 08:01:28 +0000</pubDate><atom:modified>Thu, 16 Sep 2021 08:01:28 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-use-cilium-to-replace-calico.html</guid><description>1. 系统要求 Kubernetes， &amp;gt;= 1.16.0-0 Helm， &amp;gt;= 3.0 Linux 内核 &amp;gt;= 4.9.17 CentOS 7 升级内核过程，可以参考 Calico 下如何切换数据面到 eBPF 。 2. 卸载 Calico 删除集群资源 1 2 3 4 5 6 kubectl -n kube-system delete ds calico-node kubectl -n kube-system delete deploy calico-kube-controllers kubectl -n kube-system delete sa calico-node kubectl -n kube-system delete sa calico-kube-controllers kubectl -n kube-system delete cm calico-config kubectl -n kube-system delete secret calico-config 1 kubectl get crd | grep calico | awk &amp;#39;{print $1}&amp;#39; | xargs</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Cilium</category><category>Calico</category><category>Kubernetes</category><category>容器</category><category>网络</category></item><item><title>/var/lib/docker 能不能挂载远端存储</title><link>https://www.chenshaowen.com/blog/can-we-mount-var-lib-docker-to-remote-storage.html</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><atom:modified>Tue, 22 Jun 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/can-we-mount-var-lib-docker-to-remote-storage.html</guid><description>不能 1. 问题背景 基于 Kubernetes 构建可靠、稳定的运维系统时，虚拟机 (VM) 的销毁和新建是一种常态。VM 提供的是计算和内存资源，而使用外部存储，通过 StorageClass 提供给集群中的 PVC 消费。 在这样的背景下，如何快速初始化 VM 成为新的挑战。常见的思路是制作 Node 节点的 VM 镜像，提前将依赖</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>容器</category><category>存储</category><category>Kubernetes</category><category>能不能</category></item><item><title>如何搭建一个私有的镜像仓库 mirror</title><link>https://www.chenshaowen.com/blog/how-to-run-a-private-registry-mirror.html</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><atom:modified>Thu, 29 Apr 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/how-to-run-a-private-registry-mirror.html</guid><description>Docker 的 Mirror 仅能加速 docker.io 的镜像，而不能加速私有仓库的镜像。 1. 为什么需要一个私有的镜像仓库 mirror 公网限速 dockerhub 拉取限制频率 减少拉取镜像时间 2. 创建一个 Registry 镜像加速服务 生成一个配置文件 version: 0.1 log: fields: service: registry storage: cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registry http: addr: :5000 headers: X-Content-Type-Options: [nosniff] health: storagedriver: enabled: true interval: 10s threshold: 3 但这样启动的服务只能作为 Registry</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Docker</category><category>容器</category><category>镜像</category></item><item><title>老树开新花 - Cloud Native Buildpacks</title><link>https://www.chenshaowen.com/blog/a-sample-intro-to-cloud-native-buildpacks.html</link><pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate><atom:modified>Fri, 05 Feb 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/a-sample-intro-to-cloud-native-buildpacks.html</guid><description>1. Buildpack 老树开新花 Buildpacks 项目最早是由 Heroku 在 2011 年发起, 被以 Cloud Foundry 为代表的 PaaS 平台广泛采用。在之前的文档 《PaaS 部署之 buildpack》 中, 我演示了如何将一个 Django 应用部署到 Heroku 上。 Buildpacks 不足的是产出包是 Droplet 格式, 不能直接适配容器平台。 在 2018 年 1 月, Pivotal 和 Heroku 发起了一个项</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>DevOps</category><category>Buildpack</category><category>容器</category><category>镜像</category></item><item><title>如何在主机上调试容器、在容器中操作主机</title><link>https://www.chenshaowen.com/blog/operate-host-in-container-and-debug-container-on-host.html</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><atom:modified>Mon, 11 Jan 2021 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/operate-host-in-container-and-debug-container-on-host.html</guid><description>1. 一个奇怪的需求 老板有个奇怪的需求，通过一个 kubeconfig 文件，获取主机的各种状态信息，比如进程列表、进程状态等。 第一反应就是，老板是不是不懂容器，容器怎么能这样玩，这样玩还要什么容器，内心万马奔腾。 直到最近遇到了一个命令行工具，才发现原来小丑是我自己</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>容器</category><category>安全</category><category>Kubernetes</category><category>Docker</category></item><item><title>镜像管理工具 -- Harbor</title><link>https://www.chenshaowen.com/blog/an-enterprise-class-registry-of-harbor.html</link><pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate><atom:modified>Thu, 12 Sep 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/an-enterprise-class-registry-of-harbor.html</guid><description>1. 搭建 Harbor 的要求 Harbor 硬件要求： CPU，最少 2 核，4 核更好 Mem，最少 4 GB，8 GB 更好 Disk，最少 40 GB，160 GB 更好 Docker 版本要求： 17.06.0 以上 在 Kubernetes 上搭建 Harbor ，可以参考文档，使用 Helm 搭建 harbor 。 2. Harbor 提供的功能 Harbor 是在 Docker Registry 的基础之上，进行了企业级扩展。Harbor</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Harbor</category><category>镜像</category><category>容器</category></item><item><title>Container 和 AI 是 PaaS 未来的发展方向</title><link>https://www.chenshaowen.com/blog/container-and-ai-are-the-future-directions-in-the-development-of-paas.html</link><pubDate>Sun, 03 Sep 2017 15:57:50 +0000</pubDate><atom:modified>Sun, 03 Sep 2017 15:57:50 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/container-and-ai-are-the-future-directions-in-the-development-of-paas.html</guid><description>1. 关于 PaaS 1.1 什么是 PaaS PaaS 是平台即服务（Platform as a Service）的简称，平台即服务是一种云计算服务，提供运算平台与解决方案服务。PaaS 的出现加快了 SaaS 的发展，尤其是加快了 SaaS 应用的开发速度。比如，SaaS 开发时，使用 PaaS 平台统一提供的登录</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>思考</category><category>云服务</category><category>PaaS</category><category>容器</category><category>AI</category></item></channel></rss>