<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>API on 陈少文的网站</title><link>https://www.chenshaowen.com/tags/api/</link><description>Recent content in API on 陈少文的网站</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy;2016 - {year}, All Rights Reserved.</copyright><lastBuildDate>Thu, 07 Dec 2023 00:00:00 +0000</lastBuildDate><sy:updatePeriod>weekly</sy:updatePeriod><atom:link href="https://www.chenshaowen.com/tags/api/atom.xml" rel="self" type="application/rss+xml"/><item><title>我的 Restful API 规范</title><link>https://www.chenshaowen.com/blog/my-restful-api-specification.html</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate><atom:modified>Thu, 07 Dec 2023 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/my-restful-api-specification.html</guid><description>主要用来规范自己写的 API，也是为了让 LLM 更好理解我的 API。 1. Domain 尽量单独使用一个域名，例如 api.example.com 。 2. Path 统一使用小写字母。 不用包含 /api 前缀。 不要包含扩展名。 / 不要出现在末尾。 对于 Restful API，/ 用来划分资源层级，末尾的 / 会导致混淆。 使用带版本的路径 /v1 。</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>接口</category><category>API</category><category>研发</category><category>规范</category></item><item><title>OpenAI Vs Azure OpenAI API</title><link>https://www.chenshaowen.com/blog/openai-vs-azure-openai-api.html</link><pubDate>Sun, 03 Dec 2023 11:22:55 +0000</pubDate><atom:modified>Sun, 03 Dec 2023 11:22:55 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/openai-vs-azure-openai-api.html</guid><description>由于定价和限制会随时间变化，本文仅供撰写当前时间参考。 1. 术语 RPM (requests per minute) 每分钟请求次数 RPD (requests per day) 每天请求次数 TPM (tokens per minute) 每分钟 Token 数 TPD (tokens per day), 每天 Token 数 在 https://platform.openai.com/tokenizer 可以根据文本查询对应的 token 数。在 https://github.com/openai/tiktoken/blob/main/tiktoken/model.py 可以发现 text-embedding-ada-002 与 gpt-3.5、gpt-4 的词表都是 cl100k_bas</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>OpenAI</category><category>Azure</category><category>API</category><category>AI</category></item><item><title>我在给 Ops 工具写 Copilot</title><link>https://www.chenshaowen.com/blog/writing-copilot-for-my-ops-tool.html</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><atom:modified>Sat, 23 Sep 2023 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/writing-copilot-for-my-ops-tool.html</guid><description>1. 什么是 Ops 工具 https://www.chenshaowen.com/ops/ 是我日常运维最频繁使用的工具之一。 运维机器，我可以复用之前的脚本，批量进行操作。 运维集群，我可以复用之前的脚本，不用登录节点也可以操作机器。 如果遇到新的运维问题，我会马上编写 Task Yaml 对操作进行固化，方便下一次复用。 Ops 的核心操作是</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>大模型</category><category>思考</category><category>API</category><category>文档</category><category>LLM</category><category>Ops</category><category>Copilot</category></item><item><title>Kubernetes 之网络</title><link>https://www.chenshaowen.com/blog/networks-of-kubernetes.html</link><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><atom:modified>Sun, 28 Jul 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/networks-of-kubernetes.html</guid><description>1. Docker 的网络模型 1.1 bridge 模式 默认使用 bridge 模式，也可以使用 --net=bridge 指定 bridge 模式。 bridge 模式下，容器连接到同一个虚拟网桥 docker0 上。docker0 通常会占用 172.17.0.1/16 网段。同一个网桥上的容器之间，可以通过 ip 直接通信。 1.2 host 模式 使用 --net=host 指定 host 模式。 host 模式，容器与主机共享 Network Namesp</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Kubernetes</category><category>API</category><category>对象</category></item><item><title>Kubernetes 之 API</title><link>https://www.chenshaowen.com/blog/api-of-kubernetes.html</link><pubDate>Fri, 26 Jul 2019 00:00:00 +0000</pubDate><atom:modified>Fri, 26 Jul 2019 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-of-kubernetes.html</guid><description>1. Kubernetes 中的对象 Kubernetes 对象是系统中的持久实体，用于表示集群的状态。用户通过操作对象，与 Kubernetes 进行交互，告诉系统自己期望的工作负载情况。 对象的操作是通过 Kubernetes API 来实现的。每个 Kubernetes 对象包含两个嵌套的对象字段，Spec 和 Status。Spec 描述了期望的对象状态，</description><dc:creator>微信公众号</dc:creator><category>整理</category><category>Kubernetes</category><category>API</category><category>对象</category></item><item><title>restframework 中 Serializer 和 ViewSet 的 API</title><link>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</link><pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Tue, 20 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-of-viewset-and-serializer-in-rest-framework.html</guid><description>1. Serializer 1.1 数据校验 在反序列化数据时，需要对数据的合法性进行校验。这时，可以调用 is_valid() 进行验证，如果发生验证错误，可以在 .errors 属性获取错误提示信息。例如： 1 2 3 4 serializer.is_valid() # False serializer.errors # {&amp;#39;created&amp;#39;: [u&amp;#39;This field is required.&amp;#39;]} .is_valid() 方法带有一个可选的 raise_exception 标志，如果存在验证错误，将抛出 serializers.ValidationError 异常。 1 serializer.is_valid(raise_exception=True) 除了使用</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>接口</category></item><item><title>restframework 中的 Viewset 和 Serializer</title><link>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</link><pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate><atom:modified>Sun, 18 Nov 2018 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/viewset-and-serializer-in-rest-framework.html</guid><description>1. Django 中的 View Class 首先回忆一下，Django 对请求的处理逻辑。收到一次请求之后，Django 会生成一个 WSGIHandler 类型的 handler，由 handler 控制整个处理流程。 那么，请求的 URL 与 View 是如何关联的呢？ Django 首先根据 ROOT_URLCONF 的配置加载 URLconf，按顺序逐个匹配 URLconf 的 URLp</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>API</category><category>框架</category><category>接口</category></item><item><title>Vue 中使用 axios</title><link>https://www.chenshaowen.com/blog/using-axios-in-vue.html</link><pubDate>Mon, 25 Jun 2018 15:00:00 +0000</pubDate><atom:modified>Mon, 25 Jun 2018 15:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/using-axios-in-vue.html</guid><description>1. axios 安装 使用 npm 安装 1 npm install axios --save 全局注册有两种方法： 绑定到原型上 1 2 import axios from &amp;#39;axios&amp;#39; Vue.prototype.axios = axios 这种方法，每个 Vue 对象都会新增一个 axios 对象。 1 2 3 this.axios.post(apiUrl).then((res) =&amp;gt; { //do something }) 挂载到 windows 对象上 在 DOM 的任意地方，都能使用 axios 函数。 1 2 import axios from &amp;#39;axios&amp;#39; window.axios = axios; 1 2 3 axios.post(apiUrl).then((res) =&amp;gt; { //do something }) 2. axios 配置 为了配合 Django 的 CSRF</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>前端</category><category>接口</category><category>API</category><category>Vuejs</category><category>Axios</category></item><item><title>API 接口规范</title><link>https://www.chenshaowen.com/blog/api-interface-specification.html</link><pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate><atom:modified>Fri, 01 Dec 2017 00:00:00 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/api-interface-specification.html</guid><description>在 Web 应用开发的过程中，后端开发人员需要频繁的交付 API 接口，前端开发人员需要频繁的调用 API 接口。为了降低沟通成本、预防可能的安全风险，遵循约定优于配置的原则，有必要规范 API 的接口规范。Restful API 是以资源为核心的 API 设计思路，所有的操作都是针对特</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>研发</category><category>规范</category></item><item><title>Axios ajax</title><link>https://www.chenshaowen.com/blog/axios-ajax.html</link><pubDate>Fri, 04 Aug 2017 07:07:11 +0000</pubDate><atom:modified>Fri, 04 Aug 2017 07:07:11 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/axios-ajax.html</guid><description>1. 基本概念 1.1 Ajax Ajax 全称为 &amp;quot; Asynchronous JavaScript and XML &amp;ldquo;（异步 JavaScript 和 XML ）。其核心由 JavaScript、XmlHttpRequest 、DOM 对象组成，通过 XmlHttpRequest 对象，向服务器发送异步请求，从服务器获得数据，然后用 JavaScript 来操作 DOM 而更新页面。 以 Jquery 为例： 1 2 3 4 5 6</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>前端</category><category>工具</category><category>Axios</category><category>Ajax</category><category>API</category></item><item><title>Django REST Framework 权限管理</title><link>https://www.chenshaowen.com/blog/permissions-of-django-rest-framework.html</link><pubDate>Fri, 07 Jul 2017 06:47:19 +0000</pubDate><atom:modified>Fri, 07 Jul 2017 06:47:19 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/permissions-of-django-rest-framework.html</guid><description>1. DRF的权限管理 Django REST Framework的权限管理包括两个部分。 一个是认证Authentication方式。指定对用户进行鉴权的方式，获取request.user。 一个是权限控制Permissions。针对Django资源、用户类别进行权限</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>后端</category><category>安全</category><category>API</category><category>权限</category></item><item><title>Django REST Framework 入门</title><link>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</link><pubDate>Thu, 22 Jun 2017 23:50:15 +0000</pubDate><atom:modified>Thu, 22 Jun 2017 23:50:15 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/101-of-django-rest-framework.html</guid><description>笔者从事的SaaS开发，对开发效率有着比较高的要求。从项目立项、原型设计评估、需求确定、前端设计、后台开发到最后的验收，几个星期完成一次迭代。在敏捷开发的指导下，开始推行前后端分离模式。前端专注于页面和交互，后端专注于API接口。后端提供A</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>数据</category><category>后端</category><category>接口</category><category>Django</category><category>API</category></item><item><title>Apidoc 实践和自动化生成</title><link>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</link><pubDate>Wed, 14 Jun 2017 17:22:45 +0000</pubDate><atom:modified>Wed, 14 Jun 2017 17:22:45 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/practice-and-automation-generation-of-apidoc.html</guid><description>在前后端分离框架中，API 文档频繁交接。如果涉及到第三方接口调用，多方合作场景下，API 和文档变更可能会更快。为了方便维护 API 和交接文档，这里给大家推荐一款文档生成工具 - apidoc 1.apidoc 简介 apidoc 是一个基于 nodejs 的 API 文档生成工具，从代码注释中提取特定格式的内容，</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>文档</category><category>研发</category></item><item><title>Django Restful 接口之 Tastypie</title><link>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</link><pubDate>Tue, 13 Jun 2017 21:31:13 +0000</pubDate><atom:modified>Tue, 13 Jun 2017 21:31:13 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/restful-api-of-using-django-tastypie.html</guid><description>1. Restful REST，是Representational State Transfer的缩写，表现层状态转化。Restful，是一种开发理念，万维网软件架构风格。 1.1 Restful特点 抽象资源 图片、文本、歌曲、视频都是一种资源实体，在网络上，被抽象为资源。在Re</description><dc:creator>微信公众号</dc:creator><category>博文</category><category>Django</category><category>接口</category><category>API</category><category>Tastypie</category></item><item><title>Python中常见的内建函数</title><link>https://www.chenshaowen.com/blog/built-in-functions-in-python.html</link><pubDate>Sat, 11 Feb 2017 13:48:34 +0000</pubDate><atom:modified>Sat, 11 Feb 2017 13:48:34 +0000</atom:modified><guid>https://www.chenshaowen.com/blog/built-in-functions-in-python.html</guid><description>函数 描述 abs(number) 返回一个数的绝对值 apply(function[, args[, kwds]]) 调用给定函数，可选择提供参数 all(iterable) 如果所有iterable的元素均为真则返回True, 否则返回False any(iterable) 如果有任一iterable的元素为真则返回True，否则返回False basestring() str和unicode抽象超类，</description><dc:creator>微信公众号</dc:creator><category>Python</category><category>API</category><category>整理</category><category>函数</category></item></channel></rss>